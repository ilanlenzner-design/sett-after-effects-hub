(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push(["object" == typeof document ? document.currentScript : void 0, 52683, t => {
  "use strict"; let e, i, s; var n, r = t.i(43476), a = t.i(71645); let o = t => { let e = t.replace(/^([A-Z])|[\s-_]+(\w)/g, (t, e, i) => i ? i.toUpperCase() : e.toLowerCase()); return e.charAt(0).toUpperCase() + e.slice(1) }, l = (...t) => t.filter((t, e, i) => !!t && "" !== t.trim() && i.indexOf(t) === e).join(" ").trim(); var h = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }; let u = (0, a.forwardRef)(({ color: t = "currentColor", size: e = 24, strokeWidth: i = 2, absoluteStrokeWidth: s, className: n = "", children: r, iconNode: o, ...u }, d) => (0, a.createElement)("svg", { ref: d, ...h, width: e, height: e, stroke: t, strokeWidth: s ? 24 * Number(i) / Number(e) : i, className: l("lucide", n), ...!r && !(t => { for (let e in t) if (e.startsWith("aria-") || "role" === e || "title" === e) return !0 })(u) && { "aria-hidden": "true" }, ...u }, [...o.map(([t, e]) => (0, a.createElement)(t, e)), ...Array.isArray(r) ? r : [r]])), d = (t, e) => { let i = (0, a.forwardRef)(({ className: i, ...s }, n) => (0, a.createElement)(u, { ref: n, iconNode: e, className: l(`lucide-${o(t).replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()}`, `lucide-${t}`, i), ...s })); return i.displayName = o(t), i }, c = d("upload", [["path", { d: "M12 3v12", key: "1x0j5s" }], ["path", { d: "m17 8-5-5-5 5", key: "7q97r8" }], ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }]]), p = d("music", [["path", { d: "M9 18V5l12-2v13", key: "1jmyc2" }], ["circle", { cx: "6", cy: "18", r: "3", key: "fqmcym" }], ["circle", { cx: "18", cy: "16", r: "3", key: "1hluhg" }]]), m = d("play", [["path", { d: "M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z", key: "10ikf1" }]]), f = d("pause", [["rect", { x: "14", y: "3", width: "5", height: "18", rx: "1", key: "kaeet6" }], ["rect", { x: "5", y: "3", width: "5", height: "18", rx: "1", key: "1wsw3u" }]]), g = d("wand-sparkles", [["path", { d: "m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72", key: "ul74o6" }], ["path", { d: "m14 7 3 3", key: "1r5n42" }], ["path", { d: "M5 6v4", key: "ilb8ba" }], ["path", { d: "M19 14v4", key: "blhpug" }], ["path", { d: "M10 2v2", key: "7u0qdc" }], ["path", { d: "M7 8H3", key: "zfb6yr" }], ["path", { d: "M21 16h-4", key: "1cnmox" }], ["path", { d: "M11 3H9", key: "1obp7u" }]]), y = d("loader-circle", [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]]); var v = t.i(7670), x = t.i(19056); function w(...t) { return (0, x.twMerge)((0, v.clsx)(t)) } let b = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], T = new Set(b), P = t => 180 * t / Math.PI, S = t => M(P(Math.atan2(t[1], t[0]))), A = { x: 4, y: 5, translateX: 4, translateY: 5, scaleX: 0, scaleY: 3, scale: t => (Math.abs(t[0]) + Math.abs(t[3])) / 2, rotate: S, rotateZ: S, skewX: t => P(Math.atan(t[1])), skewY: t => P(Math.atan(t[2])), skew: t => (Math.abs(t[1]) + Math.abs(t[2])) / 2 }, M = t => ((t %= 360) < 0 && (t += 360), t), E = t => Math.sqrt(t[0] * t[0] + t[1] * t[1]), C = t => Math.sqrt(t[4] * t[4] + t[5] * t[5]), V = { x: 12, y: 13, z: 14, translateX: 12, translateY: 13, translateZ: 14, scaleX: E, scaleY: C, scale: t => (E(t) + C(t)) / 2, rotateX: t => M(P(Math.atan2(t[6], t[5]))), rotateY: t => M(P(Math.atan2(-t[2], t[0]))), rotateZ: S, rotate: S, skewX: t => P(Math.atan(t[4])), skewY: t => P(Math.atan(t[1])), skew: t => (Math.abs(t[1]) + Math.abs(t[4])) / 2 }; function k(t) { return +!!t.includes("scale") } function j(t, e) { let i, s; if (!t || "none" === t) return k(e); let n = t.match(/^matrix3d\(([-\d.e\s,]+)\)$/u); if (n) i = V, s = n; else { let e = t.match(/^matrix\(([-\d.e\s,]+)\)$/u); i = A, s = e } if (!s) return k(e); let r = i[e], a = s[1].split(",").map(D); return "function" == typeof r ? r(a) : a[r] } function D(t) { return parseFloat(t.trim()) } let R = t => e => "string" == typeof e && e.startsWith(t), L = R("--"), F = R("var(--"), B = t => !!F(t) && N.test(t.split("/*")[0].trim()), N = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu; function O({ top: t, left: e, right: i, bottom: s }) { return { x: { min: e, max: i }, y: { min: t, max: s } } } let I = (t, e, i) => t + (e - t) * i; function U(t) { return void 0 === t || 1 === t } function $({ scale: t, scaleX: e, scaleY: i }) { return !U(t) || !U(e) || !U(i) } function W(t) { return $(t) || z(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY } function z(t) { var e, i; return (e = t.x) && "0%" !== e || (i = t.y) && "0%" !== i } function Y(t, e, i, s, n) { return void 0 !== n && (t = s + n * (t - s)), s + i * (t - s) + e } function H(t, e = 0, i = 1, s, n) { t.min = Y(t.min, e, i, s, n), t.max = Y(t.max, e, i, s, n) } function X(t, { x: e, y: i }) { H(t.x, e.translate, e.scale, e.originPoint), H(t.y, i.translate, i.scale, i.originPoint) } function _(t, e) { t.min = t.min + e, t.max = t.max + e } function K(t, e, i, s, n = .5) { let r = I(t.min, t.max, n); H(t, e, i, r, s) } function q(t, e) { K(t.x, e.x, e.scaleX, e.scale, e.originX), K(t.y, e.y, e.scaleY, e.scale, e.originY) } function G(t, e) { return O(function (t, e) { if (!e) return t; let i = e({ x: t.left, y: t.top }), s = e({ x: t.right, y: t.bottom }); return { top: i.y, left: i.x, bottom: s.y, right: s.x } }(t.getBoundingClientRect(), e)) } let Z = new Set(["width", "height", "top", "left", "right", "bottom", ...b]), J = (t, e, i) => i > e ? e : i < t ? t : i, Q = { test: t => "number" == typeof t, parse: parseFloat, transform: t => t }, tt = { ...Q, transform: t => J(0, 1, t) }, te = { ...Q, default: 1 }, ti = t => ({ test: e => "string" == typeof e && e.endsWith(t) && 1 === e.split(" ").length, parse: parseFloat, transform: e => `${e}${t}` }), ts = ti("deg"), tn = ti("%"), tr = ti("px"), ta = ti("vh"), to = ti("vw"), tl = { ...tn, parse: t => tn.parse(t) / 100, transform: t => tn.transform(100 * t) }, th = t => e => e.test(t), tu = [Q, tr, tn, ts, to, ta, { test: t => "auto" === t, parse: t => t }], td = t => tu.find(th(t)); t.i(47167); let tc = () => { }, tp = () => { }, tm = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u, tf = t => t === Q || t === tr, tg = new Set(["x", "y", "z"]), ty = b.filter(t => !tg.has(t)), tv = { width: ({ x: t }, { paddingLeft: e = "0", paddingRight: i = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(i), height: ({ y: t }, { paddingTop: e = "0", paddingBottom: i = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(i), top: (t, { top: e }) => parseFloat(e), left: (t, { left: e }) => parseFloat(e), bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min), right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min), x: (t, { transform: e }) => j(e, "x"), y: (t, { transform: e }) => j(e, "y") }; tv.translateX = tv.x, tv.translateY = tv.y; let tx = t => t, tw = {}, tb = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"]; function tT(t, e) { let i = !1, s = !0, n = { delta: 0, timestamp: 0, isProcessing: !1 }, r = () => i = !0, a = tb.reduce((t, i) => (t[i] = function (t, e) { let i = new Set, s = new Set, n = !1, r = !1, a = new WeakSet, o = { delta: 0, timestamp: 0, isProcessing: !1 }, l = 0; function h(e) { a.has(e) && (u.schedule(e), t()), l++, e(o) } let u = { schedule: (t, e = !1, r = !1) => { let o = r && n ? i : s; return e && a.add(t), o.has(t) || o.add(t), t }, cancel: t => { s.delete(t), a.delete(t) }, process: t => { if (o = t, n) { r = !0; return } n = !0, [i, s] = [s, i], i.forEach(h), e, l = 0, i.clear(), n = !1, r && (r = !1, u.process(t)) } }; return u }(r, e ? i : void 0), t), {}), { setup: o, read: l, resolveKeyframes: h, preUpdate: u, update: d, preRender: c, render: p, postRender: m } = a, f = () => { let r = tw.useManualTiming ? n.timestamp : performance.now(); i = !1, tw.useManualTiming || (n.delta = s ? 1e3 / 60 : Math.max(Math.min(r - n.timestamp, 40), 1)), n.timestamp = r, n.isProcessing = !0, o.process(n), l.process(n), h.process(n), u.process(n), d.process(n), c.process(n), p.process(n), m.process(n), n.isProcessing = !1, i && e && (s = !1, t(f)) }; return { schedule: tb.reduce((e, r) => { let o = a[r]; return e[r] = (e, r = !1, a = !1) => (!i && (i = !0, s = !0, n.isProcessing || t(f)), o.schedule(e, r, a)), e }, {}), cancel: t => { for (let e = 0; e < tb.length; e++)a[tb[e]].cancel(t) }, state: n, steps: a } } let { schedule: tP, cancel: tS, state: tA, steps: tM } = tT("undefined" != typeof requestAnimationFrame ? requestAnimationFrame : tx, !0), tE = new Set, tC = !1, tV = !1, tk = !1; function tj() { if (tV) { let t = Array.from(tE).filter(t => t.needsMeasurement), e = new Set(t.map(t => t.element)), i = new Map; e.forEach(t => { let e, s = (e = [], ty.forEach(i => { let s = t.getValue(i); void 0 !== s && (e.push([i, s.get()]), s.set(+!!i.startsWith("scale"))) }), e); s.length && (i.set(t, s), t.render()) }), t.forEach(t => t.measureInitialState()), e.forEach(t => { t.render(); let e = i.get(t); e && e.forEach(([e, i]) => { t.getValue(e)?.set(i) }) }), t.forEach(t => t.measureEndState()), t.forEach(t => { void 0 !== t.suspendedScrollY && window.scrollTo(0, t.suspendedScrollY) }) } tV = !1, tC = !1, tE.forEach(t => t.complete(tk)), tE.clear() } function tD() { tE.forEach(t => { t.readKeyframes(), t.needsMeasurement && (tV = !0) }) } class tR { constructor(t, e, i, s, n, r = !1) { this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = e, this.name = i, this.motionValue = s, this.element = n, this.isAsync = r } scheduleResolve() { this.state = "scheduled", this.isAsync ? (tE.add(this), tC || (tC = !0, tP.read(tD), tP.resolveKeyframes(tj))) : (this.readKeyframes(), this.complete()) } readKeyframes() { let { unresolvedKeyframes: t, name: e, element: i, motionValue: s } = this; if (null === t[0]) { let n = s?.get(), r = t[t.length - 1]; if (void 0 !== n) t[0] = n; else if (i && e) { let s = i.readValue(e, r); null != s && (t[0] = s) } void 0 === t[0] && (t[0] = r), s && void 0 === n && s.set(t[0]) } for (let e = 1; e < t.length; e++)t[e] ?? (t[e] = t[e - 1]) } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete(t = !1) { this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), tE.delete(this) } cancel() { "scheduled" === this.state && (tE.delete(this), this.state = "pending") } resume() { "pending" === this.state && this.scheduleResolve() } } let tL = t => Math.round(1e5 * t) / 1e5, tF = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu, tB = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, tN = (t, e) => i => !!("string" == typeof i && tB.test(i) && i.startsWith(t) || e && null != i && Object.prototype.hasOwnProperty.call(i, e)), tO = (t, e, i) => s => { if ("string" != typeof s) return s; let [n, r, a, o] = s.match(tF); return { [t]: parseFloat(n), [e]: parseFloat(r), [i]: parseFloat(a), alpha: void 0 !== o ? parseFloat(o) : 1 } }, tI = { ...Q, transform: t => Math.round(J(0, 255, t)) }, tU = { test: tN("rgb", "red"), parse: tO("red", "green", "blue"), transform: ({ red: t, green: e, blue: i, alpha: s = 1 }) => "rgba(" + tI.transform(t) + ", " + tI.transform(e) + ", " + tI.transform(i) + ", " + tL(tt.transform(s)) + ")" }, t$ = { test: tN("#"), parse: function (t) { let e = "", i = "", s = "", n = ""; return t.length > 5 ? (e = t.substring(1, 3), i = t.substring(3, 5), s = t.substring(5, 7), n = t.substring(7, 9)) : (e = t.substring(1, 2), i = t.substring(2, 3), s = t.substring(3, 4), n = t.substring(4, 5), e += e, i += i, s += s, n += n), { red: parseInt(e, 16), green: parseInt(i, 16), blue: parseInt(s, 16), alpha: n ? parseInt(n, 16) / 255 : 1 } }, transform: tU.transform }, tW = { test: tN("hsl", "hue"), parse: tO("hue", "saturation", "lightness"), transform: ({ hue: t, saturation: e, lightness: i, alpha: s = 1 }) => "hsla(" + Math.round(t) + ", " + tn.transform(tL(e)) + ", " + tn.transform(tL(i)) + ", " + tL(tt.transform(s)) + ")" }, tz = { test: t => tU.test(t) || t$.test(t) || tW.test(t), parse: t => tU.test(t) ? tU.parse(t) : tW.test(t) ? tW.parse(t) : t$.parse(t), transform: t => "string" == typeof t ? t : t.hasOwnProperty("red") ? tU.transform(t) : tW.transform(t), getAnimatableNone: t => { let e = tz.parse(t); return e.alpha = 0, tz.transform(e) } }, tY = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu, tH = "number", tX = "color", t_ = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function tK(t) { let e = t.toString(), i = [], s = { color: [], number: [], var: [] }, n = [], r = 0, a = e.replace(t_, t => (tz.test(t) ? (s.color.push(r), n.push(tX), i.push(tz.parse(t))) : t.startsWith("var(") ? (s.var.push(r), n.push("var"), i.push(t)) : (s.number.push(r), n.push(tH), i.push(parseFloat(t))), ++r, "${}")).split("${}"); return { values: i, split: a, indexes: s, types: n } } function tq(t) { return tK(t).values } function tG(t) { let { split: e, types: i } = tK(t), s = e.length; return t => { let n = ""; for (let r = 0; r < s; r++)if (n += e[r], void 0 !== t[r]) { let e = i[r]; e === tH ? n += tL(t[r]) : e === tX ? n += tz.transform(t[r]) : n += t[r] } return n } } let tZ = t => "number" == typeof t ? 0 : tz.test(t) ? tz.getAnimatableNone(t) : t, tJ = { test: function (t) { return isNaN(t) && "string" == typeof t && (t.match(tF)?.length || 0) + (t.match(tY)?.length || 0) > 0 }, parse: tq, createTransformer: tG, getAnimatableNone: function (t) { let e = tq(t); return tG(t)(e.map(tZ)) } }, tQ = new Set(["brightness", "contrast", "saturate", "opacity"]); function t0(t) { let [e, i] = t.slice(0, -1).split("("); if ("drop-shadow" === e) return t; let [s] = i.match(tF) || []; if (!s) return t; let n = i.replace(s, ""), r = +!!tQ.has(e); return s !== i && (r *= 100), e + "(" + r + n + ")" } let t1 = /\b([a-z-]*)\(.*?\)/gu, t2 = { ...tJ, getAnimatableNone: t => { let e = t.match(t1); return e ? e.map(t0).join(" ") : t } }, t5 = { ...Q, transform: Math.round }, t3 = { borderWidth: tr, borderTopWidth: tr, borderRightWidth: tr, borderBottomWidth: tr, borderLeftWidth: tr, borderRadius: tr, radius: tr, borderTopLeftRadius: tr, borderTopRightRadius: tr, borderBottomRightRadius: tr, borderBottomLeftRadius: tr, width: tr, maxWidth: tr, height: tr, maxHeight: tr, top: tr, right: tr, bottom: tr, left: tr, padding: tr, paddingTop: tr, paddingRight: tr, paddingBottom: tr, paddingLeft: tr, margin: tr, marginTop: tr, marginRight: tr, marginBottom: tr, marginLeft: tr, backgroundPositionX: tr, backgroundPositionY: tr, rotate: ts, rotateX: ts, rotateY: ts, rotateZ: ts, scale: te, scaleX: te, scaleY: te, scaleZ: te, skew: ts, skewX: ts, skewY: ts, distance: tr, translateX: tr, translateY: tr, translateZ: tr, x: tr, y: tr, z: tr, perspective: tr, transformPerspective: tr, opacity: tt, originX: tl, originY: tl, originZ: tr, zIndex: t5, fillOpacity: tt, strokeOpacity: tt, numOctaves: t5 }, t6 = { ...t3, color: tz, backgroundColor: tz, outlineColor: tz, fill: tz, stroke: tz, borderColor: tz, borderTopColor: tz, borderRightColor: tz, borderBottomColor: tz, borderLeftColor: tz, filter: t2, WebkitFilter: t2 }, t4 = t => t6[t]; function t8(t, e) { let i = t4(t); return i !== t2 && (i = tJ), i.getAnimatableNone ? i.getAnimatableNone(e) : void 0 } let t9 = new Set(["auto", "none", "0"]); class t7 extends tR { constructor(t, e, i, s, n) { super(t, e, i, s, n, !0) } readKeyframes() { let { unresolvedKeyframes: t, element: e, name: i } = this; if (!e || !e.current) return; super.readKeyframes(); for (let i = 0; i < t.length; i++) { let s = t[i]; if ("string" == typeof s && B(s = s.trim())) { let n = function t(e, i, s = 1) { tp(s <= 4, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`, "max-css-var-depth"); let [n, r] = function (t) { let e = tm.exec(t); if (!e) return [,]; let [, i, s, n] = e; return [`--${i ?? s}`, n] }(e); if (!n) return; let a = window.getComputedStyle(i).getPropertyValue(n); if (a) { let t = a.trim(); return /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t) ? parseFloat(t) : t } return B(r) ? t(r, i, s + 1) : r }(s, e.current); void 0 !== n && (t[i] = n), i === t.length - 1 && (this.finalKeyframe = s) } } if (this.resolveNoneKeyframes(), !Z.has(i) || 2 !== t.length) return; let [s, n] = t, r = td(s), a = td(n); if (r !== a) if (tf(r) && tf(a)) for (let e = 0; e < t.length; e++) { let i = t[e]; "string" == typeof i && (t[e] = parseFloat(i)) } else tv[i] && (this.needsMeasurement = !0) } resolveNoneKeyframes() { let { unresolvedKeyframes: t, name: e } = this, i = []; for (let e = 0; e < t.length; e++)(null === t[e] || function (t) { if ("number" == typeof t) return 0 === t; if (null === t) return !0; return "none" === t || "0" === t || /^0[^.\s]+$/u.test(t) }(t[e])) && i.push(e); i.length && function (t, e, i) { let s, n = 0; for (; n < t.length && !s;) { let e = t[n]; "string" == typeof e && !t9.has(e) && tK(e).values.length && (s = t[n]), n++ } if (s && i) for (let n of e) t[n] = t8(i, s) }(t, i, e) } measureInitialState() { let { element: t, unresolvedKeyframes: e, name: i } = this; if (!t || !t.current) return; "height" === i && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = tv[i](t.measureViewportBox(), window.getComputedStyle(t.current)), e[0] = this.measuredOrigin; let s = e[e.length - 1]; void 0 !== s && t.getValue(i, s).jump(s, !1) } measureEndState() { let { element: t, name: e, unresolvedKeyframes: i } = this; if (!t || !t.current) return; let s = t.getValue(e); s && s.jump(this.measuredOrigin, !1); let n = i.length - 1, r = i[n]; i[n] = tv[e](t.measureViewportBox(), window.getComputedStyle(t.current)), null !== r && void 0 === this.finalKeyframe && (this.finalKeyframe = r), this.removedTransforms?.length && this.removedTransforms.forEach(([e, i]) => { t.getValue(e).set(i) }), this.resolveNoneKeyframes() } } let et = t => !!(t && t.getVelocity); function ee() { e = void 0 } let ei = { now: () => (void 0 === e && ei.set(tA.isProcessing || tw.useManualTiming ? tA.timestamp : performance.now()), e), set: t => { e = t, queueMicrotask(ee) } }; function es(t, e) { -1 === t.indexOf(e) && t.push(e) } function en(t, e) { let i = t.indexOf(e); i > -1 && t.splice(i, 1) } class er { constructor() { this.subscriptions = [] } add(t) { return es(this.subscriptions, t), () => en(this.subscriptions, t) } notify(t, e, i) { let s = this.subscriptions.length; if (s) if (1 === s) this.subscriptions[0](t, e, i); else for (let n = 0; n < s; n++) { let s = this.subscriptions[n]; s && s(t, e, i) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } class ea { constructor(t, e = {}) { this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = t => { let e = ei.now(); if (this.updatedAt !== e && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(t), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents)) for (let t of this.dependents) t.dirty() }, this.hasAnimated = !1, this.setCurrent(t), this.owner = e.owner } setCurrent(t) { this.current = t, this.updatedAt = ei.now(), null === this.canTrackVelocity && void 0 !== t && (this.canTrackVelocity = !isNaN(parseFloat(this.current))) } setPrevFrameValue(t = this.current) { this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt } onChange(t) { return this.on("change", t) } on(t, e) { this.events[t] || (this.events[t] = new er); let i = this.events[t].add(e); return "change" === t ? () => { i(), tP.read(() => { this.events.change.getSize() || this.stop() }) } : i } clearListeners() { for (let t in this.events) this.events[t].clear() } attach(t, e) { this.passiveEffect = t, this.stopPassiveEffect = e } set(t) { this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t) } setWithVelocity(t, e, i) { this.set(e), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - i } jump(t, e = !0) { this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, e && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } dirty() { this.events.change?.notify(this.current) } addDependent(t) { this.dependents || (this.dependents = new Set), this.dependents.add(t) } removeDependent(t) { this.dependents && this.dependents.delete(t) } get() { return s && s.push(this), this.current } getPrevious() { return this.prev } getVelocity() { var t; let e = ei.now(); if (!this.canTrackVelocity || void 0 === this.prevFrameValue || e - this.updatedAt > 30) return 0; let i = Math.min(this.updatedAt - this.prevUpdatedAt, 30); return t = parseFloat(this.current) - parseFloat(this.prevFrameValue), i ? 1e3 / i * t : 0 } start(t) { return this.stop(), new Promise(e => { this.hasAnimated = !0, this.animation = t(e), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function eo(t, e) { return new ea(t, e) } let el = [...tu, tz, tJ], { schedule: eh } = tT(queueMicrotask, !1), eu = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, ed = {}; for (let t in eu) ed[t] = { isEnabled: e => eu[t].some(t => !!e[t]) }; let ec = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), ep = () => ({ x: ec(), y: ec() }), em = () => ({ min: 0, max: 0 }), ef = () => ({ x: em(), y: em() }), eg = "undefined" != typeof window, ey = { current: null }, ev = { current: !1 }, ex = new WeakMap; function ew(t) { return null !== t && "object" == typeof t && "function" == typeof t.start } function eb(t) { return "string" == typeof t || Array.isArray(t) } let eT = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], eP = ["initial", ...eT]; function eS(t) { return ew(t.animate) || eP.some(e => eb(t[e])) } function eA(t) { return !!(eS(t) || t.variants) } function eM(t) { let e = [{}, {}]; return t?.values.forEach((t, i) => { e[0][i] = t.get(), e[1][i] = t.getVelocity() }), e } function eE(t, e, i, s) { if ("function" == typeof e) { let [n, r] = eM(s); e = e(void 0 !== i ? i : t.custom, n, r) } if ("string" == typeof e && (e = t.variants && t.variants[e]), "function" == typeof e) { let [n, r] = eM(s); e = e(void 0 !== i ? i : t.custom, n, r) } return e } let eC = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; class eV { scrapeMotionValuesFromProps(t, e, i) { return {} } constructor({ parent: t, props: e, presenceContext: i, reducedMotionConfig: s, blockInitialAnimation: n, visualState: r }, a = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = tR, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { let t = ei.now(); this.renderScheduledAt < t && (this.renderScheduledAt = t, tP.render(this.render, !1, !0)) }; const { latestValues: o, renderState: l } = r; this.latestValues = o, this.baseTarget = { ...o }, this.initialValues = e.initial ? { ...o } : {}, this.renderState = l, this.parent = t, this.props = e, this.presenceContext = i, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = s, this.options = a, this.blockInitialAnimation = !!n, this.isControllingVariants = eS(e), this.isVariantNode = eA(e), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(t && t.current); const { willChange: h, ...u } = this.scrapeMotionValuesFromProps(e, {}, this); for (const t in u) { const e = u[t]; void 0 !== o[t] && et(e) && e.set(o[t]) } } mount(t) { this.current = t, ex.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((t, e) => this.bindToMotionValue(e, t)), ev.current || function () { if (ev.current = !0, eg) if (window.matchMedia) { let t = window.matchMedia("(prefers-reduced-motion)"), e = () => ey.current = t.matches; t.addEventListener("change", e), e() } else ey.current = !1 }(), this.shouldReduceMotion = "never" !== this.reducedMotionConfig && ("always" === this.reducedMotionConfig || ey.current), this.parent?.addChild(this), this.update(this.props, this.presenceContext) } unmount() { for (let t in this.projection && this.projection.unmount(), tS(this.notifyUpdate), tS(this.render), this.valueSubscriptions.forEach(t => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this), this.events) this.events[t].clear(); for (let t in this.features) { let e = this.features[t]; e && (e.unmount(), e.isMounted = !1) } this.current = null } addChild(t) { this.children.add(t), this.enteringChildren ?? (this.enteringChildren = new Set), this.enteringChildren.add(t) } removeChild(t) { this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t) } bindToMotionValue(t, e) { let i; this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)(); let s = T.has(t); s && this.onBindTransform && this.onBindTransform(); let n = e.on("change", e => { this.latestValues[t] = e, this.props.onUpdate && tP.preRender(this.notifyUpdate), s && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender() }); window.MotionCheckAppearSync && (i = window.MotionCheckAppearSync(this, t, e)), this.valueSubscriptions.set(t, () => { n(), i && i(), e.owner && e.stop() }) } sortNodePosition(t) { return this.current && this.sortInstanceNodePosition && this.type === t.type ? this.sortInstanceNodePosition(this.current, t.current) : 0 } updateFeatures() { let t = "animation"; for (t in ed) { let e = ed[t]; if (!e) continue; let { isEnabled: i, Feature: s } = e; if (!this.features[t] && s && i(this.props) && (this.features[t] = new s(this)), this.features[t]) { let e = this.features[t]; e.isMounted ? e.update() : (e.mount(), e.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : ef() } getStaticValue(t) { return this.latestValues[t] } setStaticValue(t, e) { this.latestValues[t] = e } update(t, e) { (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = e; for (let e = 0; e < eC.length; e++) { let i = eC[e]; this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]); let s = t["on" + i]; s && (this.propEventSubscriptions[i] = this.on(i, s)) } this.prevMotionValues = function (t, e, i) { for (let s in e) { let n = e[s], r = i[s]; if (et(n)) t.addValue(s, n); else if (et(r)) t.addValue(s, eo(n, { owner: t })); else if (r !== n) if (t.hasValue(s)) { let e = t.getValue(s); !0 === e.liveStyle ? e.jump(n) : e.hasAnimated || e.set(n) } else { let e = t.getStaticValue(s); t.addValue(s, eo(void 0 !== e ? e : n, { owner: t })) } } for (let s in i) void 0 === e[s] && t.removeValue(s); return e }(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(t) { return this.props.variants ? this.props.variants[t] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(t) { let e = this.getClosestVariantNode(); if (e) return e.variantChildren && e.variantChildren.add(t), () => e.variantChildren.delete(t) } addValue(t, e) { let i = this.values.get(t); e !== i && (i && this.removeValue(t), this.bindToMotionValue(t, e), this.values.set(t, e), this.latestValues[t] = e.get()) } removeValue(t) { this.values.delete(t); let e = this.valueSubscriptions.get(t); e && (e(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState) } hasValue(t) { return this.values.has(t) } getValue(t, e) { if (this.props.values && this.props.values[t]) return this.props.values[t]; let i = this.values.get(t); return void 0 === i && void 0 !== e && (i = eo(null === e ? void 0 : e, { owner: this }), this.addValue(t, i)), i } readValue(t, e) { let i = void 0 === this.latestValues[t] && this.current ? this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options) : this.latestValues[t]; if (null != i) { let s, n; if ("string" == typeof i && (s = i, /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(s) || (n = i, /^0[^.\s]+$/u.test(n)))) i = parseFloat(i); else { let s; s = i, !el.find(th(s)) && tJ.test(e) && (i = t8(t, e)) } this.setBaseTarget(t, et(i) ? i.get() : i) } return et(i) ? i.get() : i } setBaseTarget(t, e) { this.baseTarget[t] = e } getBaseTarget(t) { let e, { initial: i } = this.props; if ("string" == typeof i || "object" == typeof i) { let s = eE(this.props, i, this.presenceContext?.custom); s && (e = s[t]) } if (i && void 0 !== e) return e; let s = this.getBaseTargetFromProps(this.props, t); return void 0 === s || et(s) ? void 0 !== this.initialValues[t] && void 0 === e ? void 0 : this.baseTarget[t] : s } on(t, e) { return this.events[t] || (this.events[t] = new er), this.events[t].add(e) } notify(t, ...e) { this.events[t] && this.events[t].notify(...e) } scheduleRenderMicrotask() { eh.render(this.render) } } class ek extends eV { constructor() { super(...arguments), this.KeyframeResolver = t7 } sortInstanceNodePosition(t, e) { return 2 & t.compareDocumentPosition(e) ? 1 : -1 } getBaseTargetFromProps(t, e) { return t.style ? t.style[e] : void 0 } removeValueFromRenderState(t, { vars: e, style: i }) { delete e[t], delete i[t] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); let { children: t } = this.props; et(t) && (this.childSubscription = t.on("change", t => { this.current && (this.current.textContent = `${t}`) })) } } let ej = (t, e) => e && "number" == typeof t ? e.transform(t) : t, eD = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, eR = b.length; function eL(t, e, i) { let { style: s, vars: n, transformOrigin: r } = t, a = !1, o = !1; for (let t in e) { let i = e[t]; if (T.has(t)) { a = !0; continue } if (L(t)) { n[t] = i; continue } { let e = ej(i, t3[t]); t.startsWith("origin") ? (o = !0, r[t] = e) : s[t] = e } } if (!e.transform && (a || i ? s.transform = function (t, e, i) { let s = "", n = !0; for (let r = 0; r < eR; r++) { let a = b[r], o = t[a]; if (void 0 === o) continue; let l = !0; if (!(l = "number" == typeof o ? o === +!!a.startsWith("scale") : 0 === parseFloat(o)) || i) { let t = ej(o, t3[a]); if (!l) { n = !1; let e = eD[a] || a; s += `${e}(${t}) ` } i && (e[a] = t) } } return s = s.trim(), i ? s = i(e, n ? "" : s) : n && (s = "none"), s }(e, t.transform, i) : s.transform && (s.transform = "none")), o) { let { originX: t = "50%", originY: e = "50%", originZ: i = 0 } = r; s.transformOrigin = `${t} ${e} ${i}` } } function eF(t, { style: e, vars: i }, s, n) { let r, a = t.style; for (r in e) a[r] = e[r]; for (r in n?.applyProjectionStyles(a, s), i) a.setProperty(r, i[r]) } let eB = {}; function eN(t, { layout: e, layoutId: i }) { return T.has(t) || t.startsWith("origin") || (e || void 0 !== i) && (!!eB[t] || "opacity" === t) } function eO(t, e, i) { let { style: s } = t, n = {}; for (let r in s) (et(s[r]) || e.style && et(e.style[r]) || eN(r, t) || i?.getValue(r)?.liveStyle !== void 0) && (n[r] = s[r]); return n } class eI extends ek { constructor() { super(...arguments), this.type = "html", this.renderInstance = eF } readValueFromInstance(t, e) { if (T.has(e)) return this.projection?.isProjecting ? k(e) : ((t, e) => { let { transform: i = "none" } = getComputedStyle(t); return j(i, e) })(t, e); { let i = window.getComputedStyle(t), s = (L(e) ? i.getPropertyValue(e) : i[e]) || 0; return "string" == typeof s ? s.trim() : s } } measureInstanceViewportBox(t, { transformPagePoint: e }) { return G(t, e) } build(t, e, i) { eL(t, e, i.transformTemplate) } scrapeMotionValuesFromProps(t, e, i) { return eO(t, e, i) } } let eU = t => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), e$ = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, eW = { offset: "strokeDashoffset", array: "strokeDasharray" }; function ez(t, { attrX: e, attrY: i, attrScale: s, pathLength: n, pathSpacing: r = 1, pathOffset: a = 0, ...o }, l, h, u) { if (eL(t, o, h), l) { t.style.viewBox && (t.attrs.viewBox = t.style.viewBox); return } t.attrs = t.style, t.style = {}; let { attrs: d, style: c } = t; d.transform && (c.transform = d.transform, delete d.transform), (c.transform || d.transformOrigin) && (c.transformOrigin = d.transformOrigin ?? "50% 50%", delete d.transformOrigin), c.transform && (c.transformBox = u?.transformBox ?? "fill-box", delete d.transformBox), void 0 !== e && (d.x = e), void 0 !== i && (d.y = i), void 0 !== s && (d.scale = s), void 0 !== n && function (t, e, i = 1, s = 0, n = !0) { t.pathLength = 1; let r = n ? e$ : eW; t[r.offset] = tr.transform(-s); let a = tr.transform(e), o = tr.transform(i); t[r.array] = `${a} ${o}` }(d, n, r, a, !1) } let eY = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]), eH = t => "string" == typeof t && "svg" === t.toLowerCase(); function eX(t, e, i) { let s = eO(t, e, i); for (let i in t) (et(t[i]) || et(e[i])) && (s[-1 !== b.indexOf(i) ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i] = t[i]); return s } class e_ extends ek { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = ef } getBaseTargetFromProps(t, e) { return t[e] } readValueFromInstance(t, e) { if (T.has(e)) { let t = t4(e); return t && t.default || 0 } return e = eY.has(e) ? e : eU(e), t.getAttribute(e) } scrapeMotionValuesFromProps(t, e, i) { return eX(t, e, i) } build(t, e, i) { ez(t, e, this.isSVGTag, i.transformTemplate, i.style) } renderInstance(t, e, i, s) { for (let i in eF(t, e, void 0, s), e.attrs) t.setAttribute(eY.has(i) ? i : eU(i), e.attrs[i]) } mount(t) { this.isSVGTag = eH(t.tagName), super.mount(t) } } let eK = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function eq(t) { if ("string" != typeof t || t.includes("-")); else if (eK.indexOf(t) > -1 || /[A-Z]/u.test(t)) return !0; return !1 } let eG = (0, a.createContext)({}), eZ = (0, a.createContext)({ strict: !1 }), eJ = (0, a.createContext)({ transformPagePoint: t => t, isStatic: !1, reducedMotion: "never" }), eQ = (0, a.createContext)({}); function e0(t) { return Array.isArray(t) ? t.join(" ") : t } let e1 = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function e2(t, e, i) { for (let s in e) et(e[s]) || eN(s, i) || (t[s] = e[s]) } let e5 = () => ({ ...e1(), attrs: {} }), e3 = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function e6(t) { return t.startsWith("while") || t.startsWith("drag") && "draggable" !== t || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || e3.has(t) } let e4 = t => !e6(t); try { n = (() => { let t = Error("Cannot find module '@emotion/is-prop-valid'"); throw t.code = "MODULE_NOT_FOUND", t })().default, "function" == typeof n && (e4 = t => t.startsWith("on") ? !e6(t) : n(t)) } catch { } let e8 = (0, a.createContext)(null); function e9(t) { let e = (0, a.useRef)(null); return null === e.current && (e.current = t()), e.current } function e7(t) { return et(t) ? t.get() : t } let it = t => (e, i) => { let s = (0, a.useContext)(eQ), n = (0, a.useContext)(e8), r = () => (function ({ scrapeMotionValuesFromProps: t, createRenderState: e }, i, s, n) { return { latestValues: function (t, e, i, s) { let n = {}, r = s(t, {}); for (let t in r) n[t] = e7(r[t]); let { initial: a, animate: o } = t, l = eS(t), h = eA(t); e && h && !l && !1 !== t.inherit && (void 0 === a && (a = e.initial), void 0 === o && (o = e.animate)); let u = !!i && !1 === i.initial, d = (u = u || !1 === a) ? o : a; if (d && "boolean" != typeof d && !ew(d)) { let e = Array.isArray(d) ? d : [d]; for (let i = 0; i < e.length; i++) { let s = eE(t, e[i]); if (s) { let { transitionEnd: t, transition: e, ...i } = s; for (let t in i) { let e = i[t]; if (Array.isArray(e)) { let t = u ? e.length - 1 : 0; e = e[t] } null !== e && (n[t] = e) } for (let e in t) n[e] = t[e] } } } return n }(i, s, n, t), renderState: e() } })(t, e, s, n); return i ? r() : e9(r) }, ie = it({ scrapeMotionValuesFromProps: eO, createRenderState: e1 }), ii = it({ scrapeMotionValuesFromProps: eX, createRenderState: e5 }), is = Symbol.for("motionComponentSymbol"); function ir(t) { return t && "object" == typeof t && Object.prototype.hasOwnProperty.call(t, "current") } let ia = "data-" + eU("framerAppearId"), io = (0, a.createContext)({}), il = eg ? a.useLayoutEffect : a.useEffect; function ih(t, { forwardMotionProps: e = !1 } = {}, i, s) { i && function (t) { for (let e in t) ed[e] = { ...ed[e], ...t[e] } }(i); let n = eq(t) ? ii : ie; function o(i, o) { var l; let h, u = { ...(0, a.useContext)(eJ), ...i, layoutId: function ({ layoutId: t }) { let e = (0, a.useContext)(eG).id; return e && void 0 !== t ? e + "-" + t : t }(i) }, { isStatic: d } = u, c = function (t) { let { initial: e, animate: i } = function (t, e) { if (eS(t)) { let { initial: e, animate: i } = t; return { initial: !1 === e || eb(e) ? e : void 0, animate: eb(i) ? i : void 0 } } return !1 !== t.inherit ? e : {} }(t, (0, a.useContext)(eQ)); return (0, a.useMemo)(() => ({ initial: e, animate: i }), [e0(e), e0(i)]) }(i), p = n(i, d); if (!d && eg) { (0, a.useContext)(eZ).strict; let e = function (t) { let { drag: e, layout: i } = ed; if (!e && !i) return {}; let s = { ...e, ...i }; return { MeasureLayout: e?.isEnabled(t) || i?.isEnabled(t) ? s.MeasureLayout : void 0, ProjectionNode: s.ProjectionNode } }(u); h = e.MeasureLayout, c.visualElement = function (t, e, i, s, n) { let { visualElement: r } = (0, a.useContext)(eQ), o = (0, a.useContext)(eZ), l = (0, a.useContext)(e8), h = (0, a.useContext)(eJ).reducedMotion, u = (0, a.useRef)(null); s = s || o.renderer, !u.current && s && (u.current = s(t, { visualState: e, parent: r, props: i, presenceContext: l, blockInitialAnimation: !!l && !1 === l.initial, reducedMotionConfig: h })); let d = u.current, c = (0, a.useContext)(io); d && !d.projection && n && ("html" === d.type || "svg" === d.type) && function (t, e, i, s) { let { layoutId: n, layout: r, drag: a, dragConstraints: o, layoutScroll: l, layoutRoot: h, layoutCrossfade: u } = e; t.projection = new i(t.latestValues, e["data-framer-portal-id"] ? void 0 : function t(e) { if (e) return !1 !== e.options.allowProjection ? e.projection : t(e.parent) }(t.parent)), t.projection.setOptions({ layoutId: n, layout: r, alwaysMeasureLayout: !!a || o && ir(o), visualElement: t, animationType: "string" == typeof r ? r : "both", initialPromotionConfig: s, crossfade: u, layoutScroll: l, layoutRoot: h }) }(u.current, i, n, c); let p = (0, a.useRef)(!1); (0, a.useInsertionEffect)(() => { d && p.current && d.update(i, l) }); let m = i[ia], f = (0, a.useRef)(!!m && !window.MotionHandoffIsComplete?.(m) && window.MotionHasOptimisedAnimation?.(m)); return il(() => { d && (p.current = !0, window.MotionIsMounted = !0, d.updateFeatures(), d.scheduleRenderMicrotask(), f.current && d.animationState && d.animationState.animateChanges()) }), (0, a.useEffect)(() => { d && (!f.current && d.animationState && d.animationState.animateChanges(), f.current && (queueMicrotask(() => { window.MotionHandoffMarkAsComplete?.(m) }), f.current = !1), d.enteringChildren = void 0) }), d }(t, p, u, s, e.ProjectionNode) } return (0, r.jsxs)(eQ.Provider, { value: c, children: [h && c.visualElement ? (0, r.jsx)(h, { visualElement: c.visualElement, ...u }) : null, function (t, e, i, { latestValues: s }, n, r = !1) { let o = (eq(t) ? function (t, e, i, s) { let n = (0, a.useMemo)(() => { let i = e5(); return ez(i, e, eH(s), t.transformTemplate, t.style), { ...i.attrs, style: { ...i.style } } }, [e]); if (t.style) { let e = {}; e2(e, t.style, t), n.style = { ...e, ...n.style } } return n } : function (t, e) { let i, s, n = {}, r = (i = t.style || {}, e2(s = {}, i, t), Object.assign(s, function ({ transformTemplate: t }, e) { return (0, a.useMemo)(() => { let i = e1(); return eL(i, e, t), Object.assign({}, i.vars, i.style) }, [e]) }(t, e)), s); return t.drag && !1 !== t.dragListener && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = !0 === t.drag ? "none" : `pan-${"x" === t.drag ? "y" : "x"}`), void 0 === t.tabIndex && (t.onTap || t.onTapStart || t.whileTap) && (n.tabIndex = 0), n.style = r, n })(e, s, n, t), l = function (t, e, i) { let s = {}; for (let n in t) ("values" !== n || "object" != typeof t.values) && (e4(n) || !0 === i && e6(n) || !e && !e6(n) || t.draggable && n.startsWith("onDrag")) && (s[n] = t[n]); return s }(e, "string" == typeof t, r), h = t !== a.Fragment ? { ...l, ...o, ref: i } : {}, { children: u } = e, d = (0, a.useMemo)(() => et(u) ? u.get() : u, [u]); return (0, a.createElement)(t, { ...h, children: d }) }(t, i, (l = c.visualElement, (0, a.useCallback)(t => { t && p.onMount && p.onMount(t), l && (t ? l.mount(t) : l.unmount()), o && ("function" == typeof o ? o(t) : ir(o) && (o.current = t)) }, [l])), p, d, e)] }) } o.displayName = `motion.${"string" == typeof t ? t : `create(${t.displayName ?? t.name ?? ""})`}`; let l = (0, a.forwardRef)(o); return l[is] = t, l } function iu(t, e, i) { let s = t.getProps(); return eE(s, e, void 0 !== i ? i : s.custom, t) } function id(t, e) { return t?.[e] ?? t?.default ?? t } let ic = t => Array.isArray(t); function ip(t, e) { let i = t.getValue("willChange"); if (et(i) && i.add) return i.add(e); if (!i && tw.WillChange) { let i = new tw.WillChange("auto"); t.addValue("willChange", i), i.add(e) } } function im(t) { t.duration = 0, t.type = "keyframes" } let ig = (t, e) => i => e(t(i)), iy = (...t) => t.reduce(ig), iv = t => 1e3 * t, ix = { layout: 0, mainThread: 0, waapi: 0 }; function iw(t, e, i) { return (i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6) ? t + (e - t) * 6 * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t } function ib(t, e) { return i => i > 0 ? e : t } let iT = (t, e, i) => { let s = t * t, n = i * (e * e - s) + s; return n < 0 ? 0 : Math.sqrt(n) }, iP = [t$, tU, tW]; function iS(t) { let e = iP.find(e => e.test(t)); if (tc(!!e, `'${t}' is not an animatable color. Use the equivalent color code instead.`, "color-not-animatable"), !e) return !1; let i = e.parse(t); return e === tW && (i = function ({ hue: t, saturation: e, lightness: i, alpha: s }) { t /= 360, i /= 100; let n = 0, r = 0, a = 0; if (e /= 100) { let s = i < .5 ? i * (1 + e) : i + e - i * e, o = 2 * i - s; n = iw(o, s, t + 1 / 3), r = iw(o, s, t), a = iw(o, s, t - 1 / 3) } else n = r = a = i; return { red: Math.round(255 * n), green: Math.round(255 * r), blue: Math.round(255 * a), alpha: s } }(i)), i } let iA = (t, e) => { let i = iS(t), s = iS(e); if (!i || !s) return ib(t, e); let n = { ...i }; return t => (n.red = iT(i.red, s.red, t), n.green = iT(i.green, s.green, t), n.blue = iT(i.blue, s.blue, t), n.alpha = I(i.alpha, s.alpha, t), tU.transform(n)) }, iM = new Set(["none", "hidden"]); function iE(t, e) { return i => I(t, e, i) } function iC(t) { return "number" == typeof t ? iE : "string" == typeof t ? B(t) ? ib : tz.test(t) ? iA : ij : Array.isArray(t) ? iV : "object" == typeof t ? tz.test(t) ? iA : ik : ib } function iV(t, e) { let i = [...t], s = i.length, n = t.map((t, i) => iC(t)(t, e[i])); return t => { for (let e = 0; e < s; e++)i[e] = n[e](t); return i } } function ik(t, e) { let i = { ...t, ...e }, s = {}; for (let n in i) void 0 !== t[n] && void 0 !== e[n] && (s[n] = iC(t[n])(t[n], e[n])); return t => { for (let e in s) i[e] = s[e](t); return i } } let ij = (t, e) => { let i = tJ.createTransformer(e), s = tK(t), n = tK(e); if (!(s.indexes.var.length === n.indexes.var.length && s.indexes.color.length === n.indexes.color.length && s.indexes.number.length >= n.indexes.number.length)) return tc(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`, "complex-values-different"), ib(t, e); if (iM.has(t) && !n.values.length || iM.has(e) && !s.values.length) return iM.has(t) ? i => i <= 0 ? t : e : i => i >= 1 ? e : t; return iy(iV(function (t, e) { let i = [], s = { color: 0, var: 0, number: 0 }; for (let n = 0; n < e.values.length; n++) { let r = e.types[n], a = t.indexes[r][s[r]], o = t.values[a] ?? 0; i[n] = o, s[r]++ } return i }(s, n), n.values), i) }; function iD(t, e, i) { return "number" == typeof t && "number" == typeof e && "number" == typeof i ? I(t, e, i) : iC(t)(t, e) } let iR = t => { let e = ({ timestamp: e }) => t(e); return { start: (t = !0) => tP.update(e, t), stop: () => tS(e), now: () => tA.isProcessing ? tA.timestamp : ei.now() } }, iL = (t, e, i = 10) => { let s = "", n = Math.max(Math.round(e / i), 2); for (let e = 0; e < n; e++)s += Math.round(1e4 * t(e / (n - 1))) / 1e4 + ", "; return `linear(${s.substring(0, s.length - 2)})` }; function iF(t) { let e = 0, i = t.next(e); for (; !i.done && e < 2e4;)e += 50, i = t.next(e); return e >= 2e4 ? 1 / 0 : e } function iB(t, e, i) { var s, n; let r = Math.max(e - 5, 0); return s = i - t(r), (n = e - r) ? 1e3 / n * s : 0 } let iN = .01, iO = 2, iI = .005, iU = .5; function i$(t, e) { return t * Math.sqrt(1 - e * e) } let iW = ["duration", "bounce"], iz = ["stiffness", "damping", "mass"]; function iY(t, e) { return e.some(e => void 0 !== t[e]) } function iH(t = .3, e = .3) { let i, s = "object" != typeof t ? { visualDuration: t, keyframes: [0, 1], bounce: e } : t, { restSpeed: n, restDelta: r } = s, a = s.keyframes[0], o = s.keyframes[s.keyframes.length - 1], l = { done: !1, value: a }, { stiffness: h, damping: u, mass: d, duration: c, velocity: p, isResolvedFromDuration: m } = function (t) { let e = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...t }; if (!iY(t, iz) && iY(t, iW)) if (t.visualDuration) { let i = 2 * Math.PI / (1.2 * t.visualDuration), s = i * i, n = 2 * J(.05, 1, 1 - (t.bounce || 0)) * Math.sqrt(s); e = { ...e, mass: 1, stiffness: s, damping: n } } else { let i = function ({ duration: t = 800, bounce: e = .3, velocity: i = 0, mass: s = 1 }) { let n, r; tc(t <= iv(10), "Spring duration must be 10 seconds or less", "spring-duration-limit"); let a = 1 - e; a = J(.05, 1, a), t = J(.01, 10, t / 1e3), a < 1 ? (n = e => { let s = e * a, n = s * t; return .001 - (s - i) / i$(e, a) * Math.exp(-n) }, r = e => { let s = e * a * t, r = Math.pow(a, 2) * Math.pow(e, 2) * t, o = Math.exp(-s), l = i$(Math.pow(e, 2), a); return (s * i + i - r) * o * (-n(e) + .001 > 0 ? -1 : 1) / l }) : (n = e => -.001 + Math.exp(-e * t) * ((e - i) * t + 1), r = e => t * t * (i - e) * Math.exp(-e * t)); let o = function (t, e, i) { let s = i; for (let i = 1; i < 12; i++)s -= t(s) / e(s); return s }(n, r, 5 / t); if (t = iv(t), isNaN(o)) return { stiffness: 100, damping: 10, duration: t }; { let e = Math.pow(o, 2) * s; return { stiffness: e, damping: 2 * a * Math.sqrt(s * e), duration: t } } }(t); (e = { ...e, ...i, mass: 1 }).isResolvedFromDuration = !0 } return e }({ ...s, velocity: -((s.velocity || 0) / 1e3) }), f = p || 0, g = u / (2 * Math.sqrt(h * d)), y = o - a, v = Math.sqrt(h / d) / 1e3, x = 5 > Math.abs(y); if (n || (n = x ? iN : iO), r || (r = x ? iI : iU), g < 1) { let t = i$(v, g); i = e => o - Math.exp(-g * v * e) * ((f + g * v * y) / t * Math.sin(t * e) + y * Math.cos(t * e)) } else if (1 === g) i = t => o - Math.exp(-v * t) * (y + (f + v * y) * t); else { let t = v * Math.sqrt(g * g - 1); i = e => { let i = Math.exp(-g * v * e), s = Math.min(t * e, 300); return o - i * ((f + g * v * y) * Math.sinh(s) + t * y * Math.cosh(s)) / t } } let w = { calculatedDuration: m && c || null, next: t => { let e = i(t); if (m) l.done = t >= c; else { let s = 0 === t ? f : 0; g < 1 && (s = 0 === t ? iv(f) : iB(i, t, e)); let a = Math.abs(o - e) <= r; l.done = Math.abs(s) <= n && a } return l.value = l.done ? o : e, l }, toString: () => { let t = Math.min(iF(w), 2e4), e = iL(e => w.next(t * e).value, t, 30); return t + "ms " + e }, toTransition: () => { } }; return w } function iX({ keyframes: t, velocity: e = 0, power: i = .8, timeConstant: s = 325, bounceDamping: n = 10, bounceStiffness: r = 500, modifyTarget: a, min: o, max: l, restDelta: h = .5, restSpeed: u }) { let d, c, p = t[0], m = { done: !1, value: p }, f = i * e, g = p + f, y = void 0 === a ? g : a(g); y !== g && (f = y - p); let v = t => -f * Math.exp(-t / s), x = t => y + v(t), w = t => { let e = v(t), i = x(t); m.done = Math.abs(e) <= h, m.value = m.done ? y : i }, b = t => { let e; if (e = m.value, void 0 !== o && e < o || void 0 !== l && e > l) { var i; d = t, c = iH({ keyframes: [m.value, (i = m.value, void 0 === o ? l : void 0 === l || Math.abs(o - i) < Math.abs(l - i) ? o : l)], velocity: iB(x, t, m.value), damping: n, stiffness: r, restDelta: h, restSpeed: u }) } }; return b(0), { calculatedDuration: null, next: t => { let e = !1; return (c || void 0 !== d || (e = !0, w(t), b(t)), void 0 !== d && t >= d) ? c.next(t - d) : (e || w(t), m) } } } iH.applyToOptions = t => { let e = function (t, e = 100, i) { let s = i({ ...t, keyframes: [0, e] }), n = Math.min(iF(s), 2e4); return { type: "keyframes", ease: t => s.next(n * t).value / e, duration: n / 1e3 } }(t, 100, iH); return t.ease = e.ease, t.duration = iv(e.duration), t.type = "keyframes", t }; let i_ = (t, e, i) => (((1 - 3 * i + 3 * e) * t + (3 * i - 6 * e)) * t + 3 * e) * t; function iK(t, e, i, s) { return t === e && i === s ? tx : n => 0 === n || 1 === n ? n : i_(function (t, e, i, s, n) { let r, a, o = 0; do (r = i_(a = e + (i - e) / 2, s, n) - t) > 0 ? i = a : e = a; while (Math.abs(r) > 1e-7 && ++o < 12) return a }(n, 0, 1, t, i), e, s) } let iq = iK(.42, 0, 1, 1), iG = iK(0, 0, .58, 1), iZ = iK(.42, 0, .58, 1), iJ = t => e => e <= .5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, iQ = t => e => 1 - t(1 - e), i0 = iK(.33, 1.53, .69, .99), i1 = iQ(i0), i2 = iJ(i1), i5 = t => (t *= 2) < 1 ? .5 * i1(t) : .5 * (2 - Math.pow(2, -10 * (t - 1))), i3 = t => 1 - Math.sin(Math.acos(t)), i6 = iQ(i3), i4 = iJ(i3), i8 = t => Array.isArray(t) && "number" == typeof t[0], i9 = { linear: tx, easeIn: iq, easeInOut: iZ, easeOut: iG, circIn: i3, circInOut: i4, circOut: i6, backIn: i1, backInOut: i2, backOut: i0, anticipate: i5 }, i7 = t => { if (i8(t)) { tp(4 === t.length, "Cubic bezier arrays must contain four numerical values.", "cubic-bezier-length"); let [e, i, s, n] = t; return iK(e, i, s, n) } return "string" == typeof t ? (tp(void 0 !== i9[t], `Invalid easing type '${t}'`, "invalid-easing-type"), i9[t]) : t }, st = (t, e, i) => { let s = e - t; return 0 === s ? 1 : (i - t) / s }; function se({ duration: t = 300, keyframes: e, times: i, ease: s = "easeInOut" }) { var n; let r, a = Array.isArray(s) && "number" != typeof s[0] ? s.map(i7) : i7(s), o = { done: !1, value: e[0] }, l = function (t, e, { clamp: i = !0, ease: s, mixer: n } = {}) { let r = t.length; if (tp(r === e.length, "Both input and output ranges must be the same length", "range-length"), 1 === r) return () => e[0]; if (2 === r && e[0] === e[1]) return () => e[1]; let a = t[0] === t[1]; t[0] > t[r - 1] && (t = [...t].reverse(), e = [...e].reverse()); let o = function (t, e, i) { let s = [], n = i || tw.mix || iD, r = t.length - 1; for (let i = 0; i < r; i++) { let r = n(t[i], t[i + 1]); e && (r = iy(Array.isArray(e) ? e[i] || tx : e, r)), s.push(r) } return s }(e, s, n), l = o.length, h = i => { if (a && i < t[0]) return e[0]; let s = 0; if (l > 1) for (; s < t.length - 2 && !(i < t[s + 1]); s++); let n = st(t[s], t[s + 1], i); return o[s](n) }; return i ? e => h(J(t[0], t[r - 1], e)) : h }((n = i && i.length === e.length ? i : (!function (t, e) { let i = t[t.length - 1]; for (let s = 1; s <= e; s++) { let n = st(0, e, s); t.push(I(i, 1, n)) } }(r = [0], e.length - 1), r), n.map(e => e * t)), e, { ease: Array.isArray(a) ? a : e.map(() => a || iZ).splice(0, e.length - 1) }); return { calculatedDuration: t, next: e => (o.value = l(e), o.done = e >= t, o) } } let si = t => null !== t; function ss(t, { repeat: e, repeatType: i = "loop" }, s, n = 1) { let r = t.filter(si), a = n < 0 || e && "loop" !== i && e % 2 == 1 ? 0 : r.length - 1; return a && void 0 !== s ? s : r[a] } let sn = { decay: iX, inertia: iX, tween: se, keyframes: se, spring: iH }; function sr(t) { "string" == typeof t.type && (t.type = sn[t.type]) } class sa { constructor() { this.updateFinished() } get finished() { return this._finished } updateFinished() { this._finished = new Promise(t => { this.resolve = t }) } notifyFinished() { this.resolve() } then(t, e) { return this.finished.then(t, e) } } let so = t => t / 100; class sl extends sa { constructor(t) { super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => { let { motionValue: t } = this.options; t && t.updatedAt !== ei.now() && this.tick(ei.now()), this.isStopped = !0, "idle" !== this.state && (this.teardown(), this.options.onStop?.()) }, ix.mainThread++, this.options = t, this.initAnimation(), this.play(), !1 === t.autoplay && this.pause() } initAnimation() { let { options: t } = this; sr(t); let { type: e = se, repeat: i = 0, repeatDelay: s = 0, repeatType: n, velocity: r = 0 } = t, { keyframes: a } = t, o = e || se; o !== se && "number" != typeof a[0] && (this.mixKeyframes = iy(so, iD(a[0], a[1])), a = [0, 100]); let l = o({ ...t, keyframes: a }); "mirror" === n && (this.mirroredGenerator = o({ ...t, keyframes: [...a].reverse(), velocity: -r })), null === l.calculatedDuration && (l.calculatedDuration = iF(l)); let { calculatedDuration: h } = l; this.calculatedDuration = h, this.resolvedDuration = h + s, this.totalDuration = this.resolvedDuration * (i + 1) - s, this.generator = l } updateTime(t) { let e = Math.round(t - this.startTime) * this.playbackSpeed; null !== this.holdTime ? this.currentTime = this.holdTime : this.currentTime = e } tick(t, e = !1) { let { generator: i, totalDuration: s, mixKeyframes: n, mirroredGenerator: r, resolvedDuration: a, calculatedDuration: o } = this; if (null === this.startTime) return i.next(0); let { delay: l = 0, keyframes: h, repeat: u, repeatType: d, repeatDelay: c, type: p, onUpdate: m, finalKeyframe: f } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - s / this.speed, this.startTime)), e ? this.currentTime = t : this.updateTime(t); let g = this.currentTime - l * (this.playbackSpeed >= 0 ? 1 : -1), y = this.playbackSpeed >= 0 ? g < 0 : g > s; this.currentTime = Math.max(g, 0), "finished" === this.state && null === this.holdTime && (this.currentTime = s); let v = this.currentTime, x = i; if (u) { let t = Math.min(this.currentTime, s) / a, e = Math.floor(t), i = t % 1; !i && t >= 1 && (i = 1), 1 === i && e--, (e = Math.min(e, u + 1)) % 2 && ("reverse" === d ? (i = 1 - i, c && (i -= c / a)) : "mirror" === d && (x = r)), v = J(0, 1, i) * a } let w = y ? { done: !1, value: h[0] } : x.next(v); n && (w.value = n(w.value)); let { done: b } = w; y || null === o || (b = this.playbackSpeed >= 0 ? this.currentTime >= s : this.currentTime <= 0); let T = null === this.holdTime && ("finished" === this.state || "running" === this.state && b); return T && p !== iX && (w.value = ss(h, this.options, f, this.speed)), m && m(w.value), T && this.finish(), w } then(t, e) { return this.finished.then(t, e) } get duration() { return this.calculatedDuration / 1e3 } get iterationDuration() { let { delay: t = 0 } = this.options || {}; return this.duration + t / 1e3 } get time() { return this.currentTime / 1e3 } set time(t) { t = iv(t), this.currentTime = t, null === this.startTime || null !== this.holdTime || 0 === this.playbackSpeed ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), this.driver?.start(!1) } get speed() { return this.playbackSpeed } set speed(t) { this.updateTime(ei.now()); let e = this.playbackSpeed !== t; this.playbackSpeed = t, e && (this.time = this.currentTime / 1e3) } play() { if (this.isStopped) return; let { driver: t = iR, startTime: e } = this.options; this.driver || (this.driver = t(t => this.tick(t))), this.options.onPlay?.(); let i = this.driver.now(); "finished" === this.state ? (this.updateFinished(), this.startTime = i) : null !== this.holdTime ? this.startTime = i - this.holdTime : this.startTime || (this.startTime = e ?? i), "finished" === this.state && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start() } pause() { this.state = "paused", this.updateTime(ei.now()), this.holdTime = this.currentTime } complete() { "running" !== this.state && this.play(), this.state = "finished", this.holdTime = null } finish() { this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.() } cancel() { this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.() } teardown() { this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null, ix.mainThread-- } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(t) { return this.startTime = 0, this.tick(t, !0) } attachTimeline(t) { return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), t.observe(this) } } function sh(t) { let e; return () => (void 0 === e && (e = t()), e) } let su = sh(() => void 0 !== window.ScrollTimeline), sd = {}, sc = (i = sh(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch (t) { return !1 } return !0 }), () => sd.linearEasing ?? i()), sp = ([t, e, i, s]) => `cubic-bezier(${t}, ${e}, ${i}, ${s})`, sm = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: sp([0, .65, .55, 1]), circOut: sp([.55, 0, 1, .45]), backIn: sp([.31, .01, .66, -.59]), backOut: sp([.33, 1.53, .69, .99]) }; function sf(t) { return "function" == typeof t && "applyToOptions" in t } class sg extends sa { constructor(t) { if (super(), this.finishedTime = null, this.isStopped = !1, !t) return; const { element: e, name: i, keyframes: s, pseudoElement: n, allowFlatten: r = !1, finalKeyframe: a, onComplete: o } = t; this.isPseudoElement = !!n, this.allowFlatten = r, this.options = t, tp("string" != typeof t.type, 'Mini animate() doesn\'t support "type" as a string.', "mini-spring"); const l = function ({ type: t, ...e }) { return sf(t) && sc() ? t.applyToOptions(e) : (e.duration ?? (e.duration = 300), e.ease ?? (e.ease = "easeOut"), e) }(t); this.animation = function (t, e, i, { delay: s = 0, duration: n = 300, repeat: r = 0, repeatType: a = "loop", ease: o = "easeOut", times: l } = {}, h) { let u = { [e]: i }; l && (u.offset = l); let d = function t(e, i) { if (e) return "function" == typeof e ? sc() ? iL(e, i) : "ease-out" : i8(e) ? sp(e) : Array.isArray(e) ? e.map(e => t(e, i) || sm.easeOut) : sm[e] }(o, n); Array.isArray(d) && (u.easing = d); let c = { delay: s, duration: n, easing: Array.isArray(d) ? "linear" : d, fill: "both", iterations: r + 1, direction: "reverse" === a ? "alternate" : "normal" }; h && (c.pseudoElement = h); let p = t.animate(u, c); return p }(e, i, s, l, n), !1 === l.autoplay && this.animation.pause(), this.animation.onfinish = () => { if (this.finishedTime = this.time, !n) { let t = ss(s, this.options, a, this.speed); this.updateMotionValue ? this.updateMotionValue(t) : i.startsWith("--") ? e.style.setProperty(i, t) : e.style[i] = t, this.animation.cancel() } o?.(), this.notifyFinished() } } play() { this.isStopped || (this.animation.play(), "finished" === this.state && this.updateFinished()) } pause() { this.animation.pause() } complete() { this.animation.finish?.() } cancel() { try { this.animation.cancel() } catch (t) { } } stop() { if (this.isStopped) return; this.isStopped = !0; let { state: t } = this; "idle" !== t && "finished" !== t && (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel()) } commitStyles() { this.isPseudoElement || this.animation.commitStyles?.() } get duration() { return Number(this.animation.effect?.getComputedTiming?.().duration || 0) / 1e3 } get iterationDuration() { let { delay: t = 0 } = this.options || {}; return this.duration + t / 1e3 } get time() { return (Number(this.animation.currentTime) || 0) / 1e3 } set time(t) { this.finishedTime = null, this.animation.currentTime = iv(t) } get speed() { return this.animation.playbackRate } set speed(t) { t < 0 && (this.finishedTime = null), this.animation.playbackRate = t } get state() { return null !== this.finishedTime ? "finished" : this.animation.playState } get startTime() { return Number(this.animation.startTime) } set startTime(t) { this.animation.startTime = t } attachTimeline({ timeline: t, observe: e }) { return (this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, t && su()) ? (this.animation.timeline = t, tx) : e(this) } } let sy = { anticipate: i5, backInOut: i2, circInOut: i4 }; class sv extends sg { constructor(t) { !function (t) { "string" == typeof t.ease && t.ease in sy && (t.ease = sy[t.ease]) }(t), sr(t), super(t), t.startTime && (this.startTime = t.startTime), this.options = t } updateMotionValue(t) { let { motionValue: e, onUpdate: i, onComplete: s, element: n, ...r } = this.options; if (!e) return; if (void 0 !== t) return void e.set(t); let a = new sl({ ...r, autoplay: !1 }), o = iv(this.finishedTime ?? this.time); e.setWithVelocity(a.sample(o - 10).value, a.sample(o).value, 10), a.stop() } } let sx = (t, e) => "zIndex" !== e && !!("number" == typeof t || Array.isArray(t) || "string" == typeof t && (tJ.test(t) || "0" === t) && !t.startsWith("url(")), sw = new Set(["opacity", "clipPath", "filter", "transform"]), sb = sh(() => Object.hasOwnProperty.call(Element.prototype, "animate")); class sT extends sa { constructor({ autoplay: t = !0, delay: e = 0, type: i = "keyframes", repeat: s = 0, repeatDelay: n = 0, repeatType: r = "loop", keyframes: a, name: o, motionValue: l, element: h, ...u }) { super(), this.stop = () => { this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel() }, this.createdAt = ei.now(); const d = { autoplay: t, delay: e, type: i, repeat: s, repeatDelay: n, repeatType: r, name: o, motionValue: l, element: h, ...u }, c = h?.KeyframeResolver || tR; this.keyframeResolver = new c(a, (t, e, i) => this.onKeyframesResolved(t, e, d, !i), o, l, h), this.keyframeResolver?.scheduleResolve() } onKeyframesResolved(t, e, i, s) { this.keyframeResolver = void 0; let { name: n, type: r, velocity: a, delay: o, isHandoff: l, onUpdate: h } = i; this.resolvedAt = ei.now(), !function (t, e, i, s) { let n = t[0]; if (null === n) return !1; if ("display" === e || "visibility" === e) return !0; let r = t[t.length - 1], a = sx(n, e), o = sx(r, e); return tc(a === o, `You are trying to animate ${e} from "${n}" to "${r}". "${a ? r : n}" is not an animatable value.`, "value-not-animatable"), !!a && !!o && (function (t) { let e = t[0]; if (1 === t.length) return !0; for (let i = 0; i < t.length; i++)if (t[i] !== e) return !0 }(t) || ("spring" === i || sf(i)) && s) }(t, n, r, a) && ((tw.instantAnimations || !o) && h?.(ss(t, i, e)), t[0] = t[t.length - 1], im(i), i.repeat = 0); let u = { startTime: s ? this.resolvedAt && this.resolvedAt - this.createdAt > 40 ? this.resolvedAt : this.createdAt : void 0, finalKeyframe: e, ...i, keyframes: t }, d = !l && function (t) { let { motionValue: e, name: i, repeatDelay: s, repeatType: n, damping: r, type: a } = t; if (!(e?.owner?.current instanceof HTMLElement)) return !1; let { onUpdate: o, transformTemplate: l } = e.owner.getProps(); return sb() && i && sw.has(i) && ("transform" !== i || !l) && !o && !s && "mirror" !== n && 0 !== r && "inertia" !== a }(u) ? new sv({ ...u, element: u.motionValue.owner.current }) : new sl(u); d.finished.then(() => this.notifyFinished()).catch(tx), this.pendingTimeline && (this.stopTimeline = d.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = d } get finished() { return this._animation ? this.animation.finished : this._finished } then(t, e) { return this.finished.finally(t).then(() => { }) } get animation() { return this._animation || (this.keyframeResolver?.resume(), tk = !0, tD(), tj(), tk = !1), this._animation } get duration() { return this.animation.duration } get iterationDuration() { return this.animation.iterationDuration } get time() { return this.animation.time } set time(t) { this.animation.time = t } get speed() { return this.animation.speed } get state() { return this.animation.state } set speed(t) { this.animation.speed = t } get startTime() { return this.animation.startTime } attachTimeline(t) { return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop() } play() { this.animation.play() } pause() { this.animation.pause() } complete() { this.animation.complete() } cancel() { this._animation && this.animation.cancel(), this.keyframeResolver?.cancel() } } let sP = t => null !== t, sS = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, sA = { type: "keyframes", duration: .8 }, sM = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, sE = (t, e, i, s = {}, n, r) => a => { let o = id(s, t) || {}, l = o.delay || s.delay || 0, { elapsed: h = 0 } = s; h -= iv(l); let u = { keyframes: Array.isArray(i) ? i : [null, i], ease: "easeOut", velocity: e.getVelocity(), ...o, delay: -h, onUpdate: t => { e.set(t), o.onUpdate && o.onUpdate(t) }, onComplete: () => { a(), o.onComplete && o.onComplete() }, name: t, motionValue: e, element: r ? void 0 : n }; !function ({ when: t, delay: e, delayChildren: i, staggerChildren: s, staggerDirection: n, repeat: r, repeatType: a, repeatDelay: o, from: l, elapsed: h, ...u }) { return !!Object.keys(u).length }(o) && Object.assign(u, ((t, { keyframes: e }) => e.length > 2 ? sA : T.has(t) ? t.startsWith("scale") ? { type: "spring", stiffness: 550, damping: 0 === e[1] ? 2 * Math.sqrt(550) : 30, restSpeed: 10 } : sS : sM)(t, u)), u.duration && (u.duration = iv(u.duration)), u.repeatDelay && (u.repeatDelay = iv(u.repeatDelay)), void 0 !== u.from && (u.keyframes[0] = u.from); let d = !1; if (!1 !== u.type && (0 !== u.duration || u.repeatDelay) || (im(u), 0 === u.delay && (d = !0)), (tw.instantAnimations || tw.skipAnimations) && (d = !0, im(u), u.delay = 0), u.allowFlatten = !o.type && !o.ease, d && !r && void 0 !== e.get()) { let t = function (t, { repeat: e, repeatType: i = "loop" }, s) { let n = t.filter(sP), r = e && "loop" !== i && e % 2 == 1 ? 0 : n.length - 1; return n[r] }(u.keyframes, o); if (void 0 !== t) return void tP.update(() => { u.onUpdate(t), u.onComplete() }) } return o.isSync ? new sl(u) : new sT(u) }; function sC(t, e, { delay: i = 0, transitionOverride: s, type: n } = {}) { let { transition: r = t.getDefaultTransition(), transitionEnd: a, ...o } = e; s && (r = s); let l = [], h = n && t.animationState && t.animationState.getState()[n]; for (let e in o) { let s = t.getValue(e, t.latestValues[e] ?? null), n = o[e]; if (void 0 === n || h && function ({ protectedKeys: t, needsAnimating: e }, i) { let s = t.hasOwnProperty(i) && !0 !== e[i]; return e[i] = !1, s }(h, e)) continue; let a = { delay: i, ...id(r || {}, e) }, u = s.get(); if (void 0 !== u && !s.isAnimating && !Array.isArray(n) && n === u && !a.velocity) continue; let d = !1; if (window.MotionHandoffAnimation) { let i = t.props[ia]; if (i) { let t = window.MotionHandoffAnimation(i, e, tP); null !== t && (a.startTime = t, d = !0) } } ip(t, e), s.start(sE(e, s, n, t.shouldReduceMotion && Z.has(e) ? { type: !1 } : a, t, d)); let c = s.animation; c && l.push(c) } return a && Promise.all(l).then(() => { tP.update(() => { a && function (t, e) { let { transitionEnd: i = {}, transition: s = {}, ...n } = iu(t, e) || {}; for (let e in n = { ...n, ...i }) { var r; let i = ic(r = n[e]) ? r[r.length - 1] || 0 : r; t.hasValue(e) ? t.getValue(e).set(i) : t.addValue(e, eo(i)) } }(t, a) }) }), l } function sV(t, e, i, s = 0, n = 1) { let r = Array.from(t).sort((t, e) => t.sortNodePosition(e)).indexOf(e), a = t.size, o = (a - 1) * s; return "function" == typeof i ? i(r, a) : 1 === n ? r * s : o - r * s } function sk(t, e, i = {}) { let s = iu(t, e, "exit" === i.type ? t.presenceContext?.custom : void 0), { transition: n = t.getDefaultTransition() || {} } = s || {}; i.transitionOverride && (n = i.transitionOverride); let r = s ? () => Promise.all(sC(t, s, i)) : () => Promise.resolve(), a = t.variantChildren && t.variantChildren.size ? (s = 0) => { let { delayChildren: r = 0, staggerChildren: a, staggerDirection: o } = n; return function (t, e, i = 0, s = 0, n = 0, r = 1, a) { let o = []; for (let l of t.variantChildren) l.notify("AnimationStart", e), o.push(sk(l, e, { ...a, delay: i + ("function" == typeof s ? 0 : s) + sV(t.variantChildren, l, s, n, r) }).then(() => l.notify("AnimationComplete", e))); return Promise.all(o) }(t, e, s, r, a, o, i) } : () => Promise.resolve(), { when: o } = n; if (!o) return Promise.all([r(), a(i.delay)]); { let [t, e] = "beforeChildren" === o ? [r, a] : [a, r]; return t().then(() => e()) } } function sj(t, e) { if (!Array.isArray(e)) return !1; let i = e.length; if (i !== t.length) return !1; for (let s = 0; s < i; s++)if (e[s] !== t[s]) return !1; return !0 } let sD = eP.length, sR = [...eT].reverse(), sL = eT.length; function sF(t = !1) { return { isActive: t, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function sB() { return { animate: sF(!0), whileInView: sF(), whileHover: sF(), whileTap: sF(), whileDrag: sF(), whileFocus: sF(), exit: sF() } } class sN { constructor(t) { this.isMounted = !1, this.node = t } update() { } } let sO = 0, sI = { x: !1, y: !1 }; function sU(t, e, i, s = { passive: !0 }) { return t.addEventListener(e, i, s), () => t.removeEventListener(e, i) } let s$ = t => "mouse" === t.pointerType ? "number" != typeof t.button || t.button <= 0 : !1 !== t.isPrimary; function sW(t) { return { point: { x: t.pageX, y: t.pageY } } } function sz(t, e, i, s) { return sU(t, e, t => s$(t) && i(t, sW(t)), s) } function sY(t) { return t.max - t.min } function sH(t, e, i, s = .5) { t.origin = s, t.originPoint = I(e.min, e.max, t.origin), t.scale = sY(i) / sY(e), t.translate = I(i.min, i.max, t.origin) - t.originPoint, (t.scale >= .9999 && t.scale <= 1.0001 || isNaN(t.scale)) && (t.scale = 1), (t.translate >= -.01 && t.translate <= .01 || isNaN(t.translate)) && (t.translate = 0) } function sX(t, e, i, s) { sH(t.x, e.x, i.x, s ? s.originX : void 0), sH(t.y, e.y, i.y, s ? s.originY : void 0) } function s_(t, e, i) { t.min = i.min + e.min, t.max = t.min + sY(e) } function sK(t, e, i) { t.min = e.min - i.min, t.max = t.min + sY(e) } function sq(t, e, i) { sK(t.x, e.x, i.x), sK(t.y, e.y, i.y) } function sG(t) { return [t("x"), t("y")] } let sZ = ({ current: t }) => t ? t.ownerDocument.defaultView : null, sJ = (t, e) => Math.abs(t - e); class sQ { constructor(t, e, { transformPagePoint: i, contextWindow: s = window, dragSnapToOrigin: n = !1, distanceThreshold: r = 3 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { var t, e; if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; let i = s2(this.lastMoveEventInfo, this.history), s = null !== this.startEvent, n = (t = i.offset, e = { x: 0, y: 0 }, Math.sqrt(sJ(t.x, e.x) ** 2 + sJ(t.y, e.y) ** 2) >= this.distanceThreshold); if (!s && !n) return; let { point: r } = i, { timestamp: a } = tA; this.history.push({ ...r, timestamp: a }); let { onStart: o, onMove: l } = this.handlers; s || (o && o(this.lastMoveEvent, i), this.startEvent = this.lastMoveEvent), l && l(this.lastMoveEvent, i) }, this.handlePointerMove = (t, e) => { this.lastMoveEvent = t, this.lastMoveEventInfo = s0(e, this.transformPagePoint), tP.update(this.updatePoint, !0) }, this.handlePointerUp = (t, e) => { this.end(); let { onEnd: i, onSessionEnd: s, resumeAnimation: n } = this.handlers; if (this.dragSnapToOrigin && n && n(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; let r = s2("pointercancel" === t.type ? this.lastMoveEventInfo : s0(e, this.transformPagePoint), this.history); this.startEvent && i && i(t, r), s && s(t, r) }, !s$(t)) return; this.dragSnapToOrigin = n, this.handlers = e, this.transformPagePoint = i, this.distanceThreshold = r, this.contextWindow = s || window; const a = s0(sW(t), this.transformPagePoint), { point: o } = a, { timestamp: l } = tA; this.history = [{ ...o, timestamp: l }]; const { onSessionStart: h } = e; h && h(t, s2(a, this.history)), this.removeListeners = iy(sz(this.contextWindow, "pointermove", this.handlePointerMove), sz(this.contextWindow, "pointerup", this.handlePointerUp), sz(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(t) { this.handlers = t } end() { this.removeListeners && this.removeListeners(), tS(this.updatePoint) } } function s0(t, e) { return e ? { point: e(t.point) } : t } function s1(t, e) { return { x: t.x - e.x, y: t.y - e.y } } function s2({ point: t }, e) { return { point: t, delta: s1(t, s5(e)), offset: s1(t, e[0]), velocity: function (t, e) { if (t.length < 2) return { x: 0, y: 0 }; let i = t.length - 1, s = null, n = s5(t); for (; i >= 0 && (s = t[i], !(n.timestamp - s.timestamp > iv(.1)));)i--; if (!s) return { x: 0, y: 0 }; let r = (n.timestamp - s.timestamp) / 1e3; if (0 === r) return { x: 0, y: 0 }; let a = { x: (n.x - s.x) / r, y: (n.y - s.y) / r }; return a.x === 1 / 0 && (a.x = 0), a.y === 1 / 0 && (a.y = 0), a }(e, .1) } } function s5(t) { return t[t.length - 1] } function s3(t, e, i) { return { min: void 0 !== e ? t.min + e : void 0, max: void 0 !== i ? t.max + i - (t.max - t.min) : void 0 } } function s6(t, e) { let i = e.min - t.min, s = e.max - t.max; return e.max - e.min < t.max - t.min && ([i, s] = [s, i]), { min: i, max: s } } function s4(t, e, i) { return { min: s8(t, e), max: s8(t, i) } } function s8(t, e) { return "number" == typeof t ? t : t[e] || 0 } let s9 = new WeakMap; class s7 { constructor(t) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = ef(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = t } start(t, { snapToCursor: e = !1, distanceThreshold: i } = {}) { let { presenceContext: s } = this.visualElement; if (s && !1 === s.isPresent) return; let n = t => { let { dragSnapToOrigin: i } = this.getProps(); i ? this.pauseAnimation() : this.stopAnimation(), e && this.snapToCursor(sW(t).point) }, r = (t, e) => { let { drag: i, dragPropagation: s, onDragStart: n } = this.getProps(); if (i && !s && (this.openDragLock && this.openDragLock(), this.openDragLock = function (t) { if ("x" === t || "y" === t) if (sI[t]) return null; else return sI[t] = !0, () => { sI[t] = !1 }; return sI.x || sI.y ? null : (sI.x = sI.y = !0, () => { sI.x = sI.y = !1 }) }(i), !this.openDragLock)) return; this.latestPointerEvent = t, this.latestPanInfo = e, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), sG(t => { let e = this.getAxisMotionValue(t).get() || 0; if (tn.test(e)) { let { projection: i } = this.visualElement; if (i && i.layout) { let s = i.layout.layoutBox[t]; s && (e = sY(s) * (parseFloat(e) / 100)) } } this.originPoint[t] = e }), n && tP.postRender(() => n(t, e)), ip(this.visualElement, "transform"); let { animationState: r } = this.visualElement; r && r.setActive("whileDrag", !0) }, a = (t, e) => { this.latestPointerEvent = t, this.latestPanInfo = e; let { dragPropagation: i, dragDirectionLock: s, onDirectionLock: n, onDrag: r } = this.getProps(); if (!i && !this.openDragLock) return; let { offset: a } = e; if (s && null === this.currentDirection) { this.currentDirection = function (t, e = 10) { let i = null; return Math.abs(t.y) > e ? i = "y" : Math.abs(t.x) > e && (i = "x"), i }(a), null !== this.currentDirection && n && n(this.currentDirection); return } this.updateAxis("x", e.point, a), this.updateAxis("y", e.point, a), this.visualElement.render(), r && r(t, e) }, o = (t, e) => { this.latestPointerEvent = t, this.latestPanInfo = e, this.stop(t, e), this.latestPointerEvent = null, this.latestPanInfo = null }, l = () => sG(t => "paused" === this.getAnimationState(t) && this.getAxisMotionValue(t).animation?.play()), { dragSnapToOrigin: h } = this.getProps(); this.panSession = new sQ(t, { onSessionStart: n, onStart: r, onMove: a, onSessionEnd: o, resumeAnimation: l }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: h, distanceThreshold: i, contextWindow: sZ(this.visualElement) }) } stop(t, e) { let i = t || this.latestPointerEvent, s = e || this.latestPanInfo, n = this.isDragging; if (this.cancel(), !n || !s || !i) return; let { velocity: r } = s; this.startAnimation(r); let { onDragEnd: a } = this.getProps(); a && tP.postRender(() => a(i, s)) } cancel() { this.isDragging = !1; let { projection: t, animationState: e } = this.visualElement; t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; let { dragPropagation: i } = this.getProps(); !i && this.openDragLock && (this.openDragLock(), this.openDragLock = null), e && e.setActive("whileDrag", !1) } updateAxis(t, e, i) { let { drag: s } = this.getProps(); if (!i || !nt(t, s, this.currentDirection)) return; let n = this.getAxisMotionValue(t), r = this.originPoint[t] + i[t]; this.constraints && this.constraints[t] && (r = function (t, { min: e, max: i }, s) { return void 0 !== e && t < e ? t = s ? I(e, t, s.min) : Math.max(t, e) : void 0 !== i && t > i && (t = s ? I(i, t, s.max) : Math.min(t, i)), t }(r, this.constraints[t], this.elastic[t])), n.set(r) } resolveConstraints() { let { dragConstraints: t, dragElastic: e } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, s = this.constraints; t && ir(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && i ? this.constraints = function (t, { top: e, left: i, bottom: s, right: n }) { return { x: s3(t.x, i, n), y: s3(t.y, e, s) } }(i.layoutBox, t) : this.constraints = !1, this.elastic = function (t = .35) { return !1 === t ? t = 0 : !0 === t && (t = .35), { x: s4(t, "left", "right"), y: s4(t, "top", "bottom") } }(e), s !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && sG(t => { var e, s; let n; !1 !== this.constraints && this.getAxisMotionValue(t) && (this.constraints[t] = (e = i.layoutBox[t], s = this.constraints[t], n = {}, void 0 !== s.min && (n.min = s.min - e.min), void 0 !== s.max && (n.max = s.max - e.min), n)) }) } resolveRefConstraints() { var t; let { dragConstraints: e, onMeasureDragConstraints: i } = this.getProps(); if (!e || !ir(e)) return !1; let s = e.current; tp(null !== s, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.", "drag-constraints-ref"); let { projection: n } = this.visualElement; if (!n || !n.layout) return !1; let r = function (t, e, i) { let s = G(t, i), { scroll: n } = e; return n && (_(s.x, n.offset.x), _(s.y, n.offset.y)), s }(s, n.root, this.visualElement.getTransformPagePoint()), a = (t = n.layout.layoutBox, { x: s6(t.x, r.x), y: s6(t.y, r.y) }); if (i) { let t = i(function ({ x: t, y: e }) { return { top: e.min, right: t.max, bottom: e.max, left: t.min } }(a)); this.hasMutatedConstraints = !!t, t && (a = O(t)) } return a } startAnimation(t) { let { drag: e, dragMomentum: i, dragElastic: s, dragTransition: n, dragSnapToOrigin: r, onDragTransitionEnd: a } = this.getProps(), o = this.constraints || {}; return Promise.all(sG(a => { if (!nt(a, e, this.currentDirection)) return; let l = o && o[a] || {}; r && (l = { min: 0, max: 0 }); let h = { type: "inertia", velocity: i ? t[a] : 0, bounceStiffness: s ? 200 : 1e6, bounceDamping: s ? 40 : 1e7, timeConstant: 750, restDelta: 1, restSpeed: 10, ...n, ...l }; return this.startAxisValueAnimation(a, h) })).then(a) } startAxisValueAnimation(t, e) { let i = this.getAxisMotionValue(t); return ip(this.visualElement, t), i.start(sE(t, i, 0, e, this.visualElement, !1)) } stopAnimation() { sG(t => this.getAxisMotionValue(t).stop()) } pauseAnimation() { sG(t => this.getAxisMotionValue(t).animation?.pause()) } getAnimationState(t) { return this.getAxisMotionValue(t).animation?.state } getAxisMotionValue(t) { let e = `_drag${t.toUpperCase()}`, i = this.visualElement.getProps(); return i[e] || this.visualElement.getValue(t, (i.initial ? i.initial[t] : void 0) || 0) } snapToCursor(t) { sG(e => { let { drag: i } = this.getProps(); if (!nt(e, i, this.currentDirection)) return; let { projection: s } = this.visualElement, n = this.getAxisMotionValue(e); if (s && s.layout) { let { min: i, max: r } = s.layout.layoutBox[e]; n.set(t[e] - I(i, r, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; let { drag: t, dragConstraints: e } = this.getProps(), { projection: i } = this.visualElement; if (!ir(e) || !i || !this.constraints) return; this.stopAnimation(); let s = { x: 0, y: 0 }; sG(t => { let e = this.getAxisMotionValue(t); if (e && !1 !== this.constraints) { var i, n; let r, a, o, l = e.get(); s[t] = (i = { min: l, max: l }, n = this.constraints[t], r = .5, a = sY(i), (o = sY(n)) > a ? r = st(n.min, n.max - a, i.min) : a > o && (r = st(i.min, i.max - o, n.min)), J(0, 1, r)) } }); let { transformTemplate: n } = this.visualElement.getProps(); this.visualElement.current.style.transform = n ? n({}, "") : "none", i.root && i.root.updateScroll(), i.updateLayout(), this.resolveConstraints(), sG(e => { if (!nt(e, t, null)) return; let i = this.getAxisMotionValue(e), { min: n, max: r } = this.constraints[e]; i.set(I(n, r, s[e])) }) } addListeners() { if (!this.visualElement.current) return; s9.set(this.visualElement, this); let t = sz(this.visualElement.current, "pointerdown", t => { let { drag: e, dragListener: i = !0 } = this.getProps(); e && i && this.start(t) }), e = () => { let { dragConstraints: t } = this.getProps(); ir(t) && t.current && (this.constraints = this.resolveRefConstraints()) }, { projection: i } = this.visualElement, s = i.addEventListener("measure", e); i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), tP.read(e); let n = sU(window, "resize", () => this.scalePositionWithinConstraints()), r = i.addEventListener("didUpdate", ({ delta: t, hasLayoutChanged: e }) => { this.isDragging && e && (sG(e => { let i = this.getAxisMotionValue(e); i && (this.originPoint[e] += t[e].translate, i.set(i.get() + t[e].translate)) }), this.visualElement.render()) }); return () => { n(), t(), s(), r && r() } } getProps() { let t = this.visualElement.getProps(), { drag: e = !1, dragDirectionLock: i = !1, dragPropagation: s = !1, dragConstraints: n = !1, dragElastic: r = .35, dragMomentum: a = !0 } = t; return { ...t, drag: e, dragDirectionLock: i, dragPropagation: s, dragConstraints: n, dragElastic: r, dragMomentum: a } } } function nt(t, e, i) { return (!0 === e || e === t) && (null === i || i === t) } let ne = t => (e, i) => { t && tP.postRender(() => t(e, i)) }; var ni = a; function ns(t = !0) { let e = (0, a.useContext)(e8); if (null === e) return [!0, null]; let { isPresent: i, onExitComplete: s, register: n } = e, r = (0, a.useId)(); (0, a.useEffect)(() => { if (t) return n(r) }, [t]); let o = (0, a.useCallback)(() => t && s && s(r), [r, s, t]); return !i && s ? [!1, o] : [!0] } let nn = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function nr(t, e) { return e.max === e.min ? 0 : t / (e.max - e.min) * 100 } let na = { correct: (t, e) => { if (!e.target) return t; if ("string" == typeof t) if (!tr.test(t)) return t; else t = parseFloat(t); let i = nr(t, e.target.x), s = nr(t, e.target.y); return `${i}% ${s}%` } }, no = !1; class nl extends ni.Component { componentDidMount() { let { visualElement: t, layoutGroup: e, switchLayoutGroup: i, layoutId: s } = this.props, { projection: n } = t; for (let t in nu) eB[t] = nu[t], L(t) && (eB[t].isCSSVariable = !0); n && (e.group && e.group.add(n), i && i.register && s && i.register(n), no && n.root.didUpdate(), n.addEventListener("animationComplete", () => { this.safeToRemove() }), n.setOptions({ ...n.options, onExitComplete: () => this.safeToRemove() })), nn.hasEverUpdated = !0 } getSnapshotBeforeUpdate(t) { let { layoutDependency: e, visualElement: i, drag: s, isPresent: n } = this.props, { projection: r } = i; return r && (r.isPresent = n, no = !0, s || t.layoutDependency !== e || void 0 === e || t.isPresent !== n ? r.willUpdate() : this.safeToRemove(), t.isPresent !== n && (n ? r.promote() : r.relegate() || tP.postRender(() => { let t = r.getStack(); t && t.members.length || this.safeToRemove() }))), null } componentDidUpdate() { let { projection: t } = this.props.visualElement; t && (t.root.didUpdate(), eh.postRender(() => { !t.currentAnimation && t.isLead() && this.safeToRemove() })) } componentWillUnmount() { let { visualElement: t, layoutGroup: e, switchLayoutGroup: i } = this.props, { projection: s } = t; no = !0, s && (s.scheduleCheckAfterUnmount(), e && e.group && e.group.remove(s), i && i.deregister && i.deregister(s)) } safeToRemove() { let { safeToRemove: t } = this.props; t && t() } render() { return null } } function nh(t) { let [e, i] = ns(), s = (0, ni.useContext)(eG); return (0, r.jsx)(nl, { ...t, layoutGroup: s, switchLayoutGroup: (0, ni.useContext)(io), isPresent: e, safeToRemove: i }) } let nu = { borderRadius: { ...na, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: na, borderTopRightRadius: na, borderBottomLeftRadius: na, borderBottomRightRadius: na, boxShadow: { correct: (t, { treeScale: e, projectionDelta: i }) => { let s = tJ.parse(t); if (s.length > 5) return t; let n = tJ.createTransformer(t), r = +("number" != typeof s[0]), a = i.x.scale * e.x, o = i.y.scale * e.y; s[0 + r] /= a, s[1 + r] /= o; let l = I(a, o, .5); return "number" == typeof s[2 + r] && (s[2 + r] /= l), "number" == typeof s[3 + r] && (s[3 + r] /= l), n(s) } } }; function nd(t) { return "object" == typeof t && null !== t } function nc(t) { return nd(t) && "ownerSVGElement" in t } let np = (t, e) => t.depth - e.depth; class nm { constructor() { this.children = [], this.isDirty = !1 } add(t) { es(this.children, t), this.isDirty = !0 } remove(t) { en(this.children, t), this.isDirty = !0 } forEach(t) { this.isDirty && this.children.sort(np), this.isDirty = !1, this.children.forEach(t) } } let nf = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], ng = nf.length, ny = t => "string" == typeof t ? parseFloat(t) : t, nv = t => "number" == typeof t || tr.test(t); function nx(t, e) { return void 0 !== t[e] ? t[e] : t.borderRadius } let nw = nT(0, .5, i6), nb = nT(.5, .95, tx); function nT(t, e, i) { return s => s < t ? 0 : s > e ? 1 : i(st(t, e, s)) } function nP(t, e) { t.min = e.min, t.max = e.max } function nS(t, e) { nP(t.x, e.x), nP(t.y, e.y) } function nA(t, e) { t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin } function nM(t, e, i, s, n) { return t -= e, t = s + 1 / i * (t - s), void 0 !== n && (t = s + 1 / n * (t - s)), t } function nE(t, e, [i, s, n], r, a) { !function (t, e = 0, i = 1, s = .5, n, r = t, a = t) { if (tn.test(e) && (e = parseFloat(e), e = I(a.min, a.max, e / 100) - a.min), "number" != typeof e) return; let o = I(r.min, r.max, s); t === r && (o -= e), t.min = nM(t.min, e, i, o, n), t.max = nM(t.max, e, i, o, n) }(t, e[i], e[s], e[n], e.scale, r, a) } let nC = ["x", "scaleX", "originX"], nV = ["y", "scaleY", "originY"]; function nk(t, e, i, s) { nE(t.x, e, nC, i ? i.x : void 0, s ? s.x : void 0), nE(t.y, e, nV, i ? i.y : void 0, s ? s.y : void 0) } function nj(t) { return 0 === t.translate && 1 === t.scale } function nD(t) { return nj(t.x) && nj(t.y) } function nR(t, e) { return t.min === e.min && t.max === e.max } function nL(t, e) { return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max) } function nF(t, e) { return nL(t.x, e.x) && nL(t.y, e.y) } function nB(t) { return sY(t.x) / sY(t.y) } function nN(t, e) { return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint } class nO { constructor() { this.members = [] } add(t) { es(this.members, t), t.scheduleRender() } remove(t) { if (en(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) { let t = this.members[this.members.length - 1]; t && this.promote(t) } } relegate(t) { let e, i = this.members.findIndex(e => t === e); if (0 === i) return !1; for (let t = i; t >= 0; t--) { let i = this.members[t]; if (!1 !== i.isPresent) { e = i; break } } return !!e && (this.promote(e), !0) } promote(t, e) { let i = this.lead; if (t !== i && (this.prevLead = i, this.lead = t, t.show(), i)) { i.instance && i.scheduleRender(), t.scheduleRender(), t.resumeFrom = i, e && (t.resumeFrom.preserveOpacity = !0), i.snapshot && (t.snapshot = i.snapshot, t.snapshot.latestValues = i.animationValues || i.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0); let { crossfade: s } = t.options; !1 === s && i.hide() } } exitAnimationComplete() { this.members.forEach(t => { let { options: e, resumingFrom: i } = t; e.onExitComplete && e.onExitComplete(), i && i.options.onExitComplete && i.options.onExitComplete() }) } scheduleRender() { this.members.forEach(t => { t.instance && t.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } let nI = ["", "X", "Y", "Z"], nU = 0; function n$(t, e, i, s) { let { latestValues: n } = e; n[t] && (i[t] = n[t], e.setStaticValue(t, 0), s && (s[t] = 0)) } function nW({ attachResizeListener: t, defaultParent: e, measureScroll: i, checkIsScrollRoot: s, resetTransform: n }) { return class { constructor(t = {}, i = e?.()) { this.id = nU++, this.animationId = 0, this.animationCommitId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, this.nodes.forEach(nH), this.nodes.forEach(nJ), this.nodes.forEach(nQ), this.nodes.forEach(nX) }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = t, this.root = i ? i.root || i : this, this.path = i ? [...i.path, i] : [], this.parent = i, this.depth = i ? i.depth + 1 : 0; for (let t = 0; t < this.path.length; t++)this.path[t].shouldResetTransform = !0; this.root === this && (this.nodes = new nm) } addEventListener(t, e) { return this.eventHandlers.has(t) || this.eventHandlers.set(t, new er), this.eventHandlers.get(t).add(e) } notifyListeners(t, ...e) { let i = this.eventHandlers.get(t); i && i.notify(...e) } hasListeners(t) { return this.eventHandlers.has(t) } mount(e) { if (this.instance) return; this.isSVG = nc(e) && !(nc(e) && "svg" === e.tagName), this.instance = e; let { layoutId: i, layout: s, visualElement: n } = this.options; if (n && !n.current && n.mount(e), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (s || i) && (this.isLayoutDirty = !0), t) { let i, s = 0, n = () => this.root.updateBlockedByResize = !1; tP.read(() => { s = window.innerWidth }), t(e, () => { let t = window.innerWidth; if (t !== s) { let e, r; s = t, this.root.updateBlockedByResize = !0, i && i(), e = ei.now(), r = ({ timestamp: t }) => { let i = t - e; i >= 250 && (tS(r), n(i - 250)) }, tP.setup(r, !0), i = () => tS(r), nn.hasAnimatedSinceResize && (nn.hasAnimatedSinceResize = !1, this.nodes.forEach(nZ)) } }) } i && this.root.registerSharedNode(i, this), !1 !== this.options.animate && n && (i || s) && this.addEventListener("didUpdate", ({ delta: t, hasLayoutChanged: e, hasRelativeLayoutChanged: i, layout: s }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } let r = this.options.transition || n.getDefaultTransition() || n6, { onLayoutAnimationStart: a, onLayoutAnimationComplete: o } = n.getProps(), l = !this.targetLayout || !nF(this.targetLayout, s), h = !e && i; if (this.options.layoutRoot || this.resumeFrom || h || e && (l || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0); let e = { ...id(r, "layout"), onPlay: a, onComplete: o }; (n.shouldReduceMotion || this.options.layoutRoot) && (e.delay = 0, e.type = !1), this.startAnimation(e), this.setAnimationOrigin(t, h) } else e || nZ(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = s }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); let t = this.getStack(); t && t.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), tS(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { !this.isUpdateBlocked() && (this.isUpdating = !0, this.nodes && this.nodes.forEach(n0), this.animationId++) } getTransformTemplate() { let { visualElement: t } = this.options; return t && t.getProps().transformTemplate } willUpdate(t = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && function t(e) { if (e.hasCheckedOptimisedAppear = !0, e.root === e) return; let { visualElement: i } = e.options; if (!i) return; let s = i.props[ia]; if (window.MotionHasOptimisedAnimation(s, "transform")) { let { layout: t, layoutId: i } = e.options; window.MotionCancelOptimisedAnimation(s, "transform", tP, !(t || i)) } let { parent: n } = e; n && !n.hasCheckedOptimisedAppear && t(n) }(this), this.root.isUpdating || this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let t = 0; t < this.path.length; t++) { let e = this.path[t]; e.shouldResetTransform = !0, e.updateScroll("snapshot"), e.options.layoutRoot && e.willUpdate(!1) } let { layoutId: e, layout: i } = this.options; if (void 0 === e && !i) return; let s = this.getTransformTemplate(); this.prevTransformTemplateValue = s ? s(this.latestValues, "") : void 0, this.updateSnapshot(), t && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(nK); return } if (this.animationId <= this.animationCommitId) return void this.nodes.forEach(nq); this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(nG), this.nodes.forEach(nz), this.nodes.forEach(nY)) : this.nodes.forEach(nq), this.clearAllSnapshots(); let t = ei.now(); tA.delta = J(0, 1e3 / 60, t - tA.timestamp), tA.timestamp = t, tA.isProcessing = !0, tM.update.process(tA), tM.preRender.process(tA), tM.render.process(tA), tA.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, eh.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(n_), this.sharedNodes.forEach(n1) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, tP.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { tP.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { !this.snapshot && this.instance && (this.snapshot = this.measure(), !this.snapshot || sY(this.snapshot.measuredBox.x) || sY(this.snapshot.measuredBox.y) || (this.snapshot = void 0)) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let t = 0; t < this.path.length; t++)this.path[t].updateScroll(); let t = this.layout; this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = ef(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); let { visualElement: e } = this.options; e && e.notify("LayoutMeasure", this.layout.layoutBox, t ? t.layoutBox : void 0) } updateScroll(t = "measure") { let e = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === t && (e = !1), e && this.instance) { let e = s(this.instance); this.scroll = { animationId: this.root.animationId, phase: t, isRoot: e, offset: i(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : e } } } resetTransform() { if (!n) return; let t = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, e = this.projectionDelta && !nD(this.projectionDelta), i = this.getTransformTemplate(), s = i ? i(this.latestValues, "") : void 0, r = s !== this.prevTransformTemplateValue; t && this.instance && (e || W(this.latestValues) || r) && (n(this.instance, s), this.shouldResetTransform = !1, this.scheduleRender()) } measure(t = !0) { var e; let i = this.measurePageBox(), s = this.removeElementScroll(i); return t && (s = this.removeTransform(s)), n9((e = s).x), n9(e.y), { animationId: this.root.animationId, measuredBox: i, layoutBox: s, latestValues: {}, source: this.id } } measurePageBox() { let { visualElement: t } = this.options; if (!t) return ef(); let e = t.measureViewportBox(); if (!(this.scroll?.wasRoot || this.path.some(rt))) { let { scroll: t } = this.root; t && (_(e.x, t.offset.x), _(e.y, t.offset.y)) } return e } removeElementScroll(t) { let e = ef(); if (nS(e, t), this.scroll?.wasRoot) return e; for (let i = 0; i < this.path.length; i++) { let s = this.path[i], { scroll: n, options: r } = s; s !== this.root && n && r.layoutScroll && (n.wasRoot && nS(e, t), _(e.x, n.offset.x), _(e.y, n.offset.y)) } return e } applyTransform(t, e = !1) { let i = ef(); nS(i, t); for (let t = 0; t < this.path.length; t++) { let s = this.path[t]; !e && s.options.layoutScroll && s.scroll && s !== s.root && q(i, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }), W(s.latestValues) && q(i, s.latestValues) } return W(this.latestValues) && q(i, this.latestValues), i } removeTransform(t) { let e = ef(); nS(e, t); for (let t = 0; t < this.path.length; t++) { let i = this.path[t]; if (!i.instance || !W(i.latestValues)) continue; $(i.latestValues) && i.updateSnapshot(); let s = ef(); nS(s, i.measurePageBox()), nk(e, i.latestValues, i.snapshot ? i.snapshot.layoutBox : void 0, s) } return W(this.latestValues) && nk(e, this.latestValues), e } setTargetDelta(t) { this.targetDelta = t, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(t) { this.options = { ...this.options, ...t, crossfade: void 0 === t.crossfade || t.crossfade } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== tA.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(t = !1) { let e = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = e.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = e.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = e.isSharedProjectionDirty); let i = !!this.resumingFrom || this !== e; if (!(t || i && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; let { layout: s, layoutId: n } = this.options; if (!this.layout || !(s || n)) return; this.resolvedRelativeTargetAt = tA.timestamp; let r = this.getClosestProjectingParent(); if (r && this.linkedParentVersion !== r.layoutVersion && !r.options.layoutRoot && this.removeRelativeTarget(), this.targetDelta || this.relativeTarget || (r && r.layout ? this.createRelativeTarget(r, this.layout.layoutBox, r.layout.layoutBox) : this.removeRelativeTarget()), this.relativeTarget || this.targetDelta) { if (this.target || (this.target = ef(), this.targetWithTransforms = ef()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) { var a, o, l; this.forceRelativeParentToResolveTarget(), a = this.target, o = this.relativeTarget, l = this.relativeParent.target, s_(a.x, o.x, l.x), s_(a.y, o.y, l.y) } else this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : nS(this.target, this.layout.layoutBox), X(this.target, this.targetDelta)) : nS(this.target, this.layout.layoutBox); this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, r && !!r.resumingFrom == !!this.resumingFrom && !r.options.layoutScroll && r.target && 1 !== this.animationProgress ? this.createRelativeTarget(r, this.target, r.target) : this.relativeParent = this.relativeTarget = void 0) } } getClosestProjectingParent() { if (!(!this.parent || $(this.parent.latestValues) || z(this.parent.latestValues))) if (this.parent.isProjecting()) return this.parent; else return this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } createRelativeTarget(t, e, i) { this.relativeParent = t, this.linkedParentVersion = t.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ef(), this.relativeTargetOrigin = ef(), sq(this.relativeTargetOrigin, e, i), nS(this.relativeTarget, this.relativeTargetOrigin) } removeRelativeTarget() { this.relativeParent = this.relativeTarget = void 0 } calcProjection() { let t = this.getLead(), e = !!this.resumingFrom || this !== t, i = !0; if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (i = !1), e && (this.isSharedProjectionDirty || this.isTransformDirty) && (i = !1), this.resolvedRelativeTargetAt === tA.timestamp && (i = !1), i) return; let { layout: s, layoutId: n } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(s || n)) return; nS(this.layoutCorrected, this.layout.layoutBox); let r = this.treeScale.x, a = this.treeScale.y; !function (t, e, i, s = !1) { let n, r, a = i.length; if (a) { e.x = e.y = 1; for (let o = 0; o < a; o++) { r = (n = i[o]).projectionDelta; let { visualElement: a } = n.options; (!a || !a.props.style || "contents" !== a.props.style.display) && (s && n.options.layoutScroll && n.scroll && n !== n.root && q(t, { x: -n.scroll.offset.x, y: -n.scroll.offset.y }), r && (e.x *= r.x.scale, e.y *= r.y.scale, X(t, r)), s && W(n.latestValues) && q(t, n.latestValues)) } e.x < 1.0000000000001 && e.x > .999999999999 && (e.x = 1), e.y < 1.0000000000001 && e.y > .999999999999 && (e.y = 1) } }(this.layoutCorrected, this.treeScale, this.path, e), t.layout && !t.target && (1 !== this.treeScale.x || 1 !== this.treeScale.y) && (t.target = t.layout.layoutBox, t.targetWithTransforms = ef()); let { target: o } = t; if (!o) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } this.projectionDelta && this.prevProjectionDelta ? (nA(this.prevProjectionDelta.x, this.projectionDelta.x), nA(this.prevProjectionDelta.y, this.projectionDelta.y)) : this.createProjectionDeltas(), sX(this.projectionDelta, this.layoutCorrected, o, this.latestValues), this.treeScale.x === r && this.treeScale.y === a && nN(this.projectionDelta.x, this.prevProjectionDelta.x) && nN(this.projectionDelta.y, this.prevProjectionDelta.y) || (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", o)) } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(t = !0) { if (this.options.visualElement?.scheduleRender(), t) { let t = this.getStack(); t && t.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = ep(), this.projectionDelta = ep(), this.projectionDeltaWithTransform = ep() } setAnimationOrigin(t, e = !1) { let i, s = this.snapshot, n = s ? s.latestValues : {}, r = { ...this.latestValues }, a = ep(); this.relativeParent && this.relativeParent.options.layoutRoot || (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !e; let o = ef(), l = (s ? s.source : void 0) !== (this.layout ? this.layout.source : void 0), h = this.getStack(), u = !h || h.members.length <= 1, d = !!(l && !u && !0 === this.options.crossfade && !this.path.some(n3)); this.animationProgress = 0, this.mixTargetDelta = e => { let s = e / 1e3; if (n2(a.x, t.x, s), n2(a.y, t.y, s), this.setTargetDelta(a), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) { var h, c, p, m, f, g; sq(o, this.layout.layoutBox, this.relativeParent.layout.layoutBox), p = this.relativeTarget, m = this.relativeTargetOrigin, f = o, g = s, n5(p.x, m.x, f.x, g), n5(p.y, m.y, f.y, g), i && (h = this.relativeTarget, c = i, nR(h.x, c.x) && nR(h.y, c.y)) && (this.isProjectionDirty = !1), i || (i = ef()), nS(i, this.relativeTarget) } l && (this.animationValues = r, function (t, e, i, s, n, r) { n ? (t.opacity = I(0, i.opacity ?? 1, nw(s)), t.opacityExit = I(e.opacity ?? 1, 0, nb(s))) : r && (t.opacity = I(e.opacity ?? 1, i.opacity ?? 1, s)); for (let n = 0; n < ng; n++) { let r = `border${nf[n]}Radius`, a = nx(e, r), o = nx(i, r); (void 0 !== a || void 0 !== o) && (a || (a = 0), o || (o = 0), 0 === a || 0 === o || nv(a) === nv(o) ? (t[r] = Math.max(I(ny(a), ny(o), s), 0), (tn.test(o) || tn.test(a)) && (t[r] += "%")) : t[r] = o) } (e.rotate || i.rotate) && (t.rotate = I(e.rotate || 0, i.rotate || 0, s)) }(r, n, this.latestValues, s, d, u)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = s }, this.mixTargetDelta(1e3 * !!this.options.layoutRoot) } startAnimation(t) { this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (tS(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = tP.update(() => { var e, i, s; let n; nn.hasAnimatedSinceResize = !0, ix.layout++, this.motionValue || (this.motionValue = eo(0)), this.currentAnimation = (e = this.motionValue, i = [0, 1e3], s = { ...t, velocity: 0, isSync: !0, onUpdate: e => { this.mixTargetDelta(e), t.onUpdate && t.onUpdate(e) }, onStop: () => { ix.layout-- }, onComplete: () => { ix.layout--, t.onComplete && t.onComplete(), this.completeAnimation() } }, (n = et(e) ? e : eo(e)).start(sE("", n, i, s)), n.animation), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); let t = this.getStack(); t && t.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(1e3), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { let t = this.getLead(), { targetWithTransforms: e, target: i, layout: s, latestValues: n } = t; if (e && i && s) { if (this !== t && this.layout && s && n7(this.options.animationType, this.layout.layoutBox, s.layoutBox)) { i = this.target || ef(); let e = sY(this.layout.layoutBox.x); i.x.min = t.target.x.min, i.x.max = i.x.min + e; let s = sY(this.layout.layoutBox.y); i.y.min = t.target.y.min, i.y.max = i.y.min + s } nS(e, i), q(e, n), sX(this.projectionDeltaWithTransform, this.layoutCorrected, e, n) } } registerSharedNode(t, e) { this.sharedNodes.has(t) || this.sharedNodes.set(t, new nO), this.sharedNodes.get(t).add(e); let i = e.options.initialPromotionConfig; e.promote({ transition: i ? i.transition : void 0, preserveFollowOpacity: i && i.shouldPreserveFollowOpacity ? i.shouldPreserveFollowOpacity(e) : void 0 }) } isLead() { let t = this.getStack(); return !t || t.lead === this } getLead() { let { layoutId: t } = this.options; return t && this.getStack()?.lead || this } getPrevLead() { let { layoutId: t } = this.options; return t ? this.getStack()?.prevLead : void 0 } getStack() { let { layoutId: t } = this.options; if (t) return this.root.sharedNodes.get(t) } promote({ needsReset: t, transition: e, preserveFollowOpacity: i } = {}) { let s = this.getStack(); s && s.promote(this, i), t && (this.projectionDelta = void 0, this.needsReset = !0), e && this.setOptions({ transition: e }) } relegate() { let t = this.getStack(); return !!t && t.relegate(this) } resetSkewAndRotation() { let { visualElement: t } = this.options; if (!t) return; let e = !1, { latestValues: i } = t; if ((i.z || i.rotate || i.rotateX || i.rotateY || i.rotateZ || i.skewX || i.skewY) && (e = !0), !e) return; let s = {}; i.z && n$("z", t, s, this.animationValues); for (let e = 0; e < nI.length; e++)n$(`rotate${nI[e]}`, t, s, this.animationValues), n$(`skew${nI[e]}`, t, s, this.animationValues); for (let e in t.render(), s) t.setStaticValue(e, s[e]), this.animationValues && (this.animationValues[e] = s[e]); t.scheduleRender() } applyProjectionStyles(t, e) { if (!this.instance || this.isSVG) return; if (!this.isVisible) { t.visibility = "hidden"; return } let i = this.getTransformTemplate(); if (this.needsReset) { this.needsReset = !1, t.visibility = "", t.opacity = "", t.pointerEvents = e7(e?.pointerEvents) || "", t.transform = i ? i(this.latestValues, "") : "none"; return } let s = this.getLead(); if (!this.projectionDelta || !this.layout || !s.target) { this.options.layoutId && (t.opacity = void 0 !== this.latestValues.opacity ? this.latestValues.opacity : 1, t.pointerEvents = e7(e?.pointerEvents) || ""), this.hasProjected && !W(this.latestValues) && (t.transform = i ? i({}, "") : "none", this.hasProjected = !1); return } t.visibility = ""; let n = s.animationValues || s.latestValues; this.applyTransformsToTarget(); let r = function (t, e, i) { let s = "", n = t.x.translate / e.x, r = t.y.translate / e.y, a = i?.z || 0; if ((n || r || a) && (s = `translate3d(${n}px, ${r}px, ${a}px) `), (1 !== e.x || 1 !== e.y) && (s += `scale(${1 / e.x}, ${1 / e.y}) `), i) { let { transformPerspective: t, rotate: e, rotateX: n, rotateY: r, skewX: a, skewY: o } = i; t && (s = `perspective(${t}px) ${s}`), e && (s += `rotate(${e}deg) `), n && (s += `rotateX(${n}deg) `), r && (s += `rotateY(${r}deg) `), a && (s += `skewX(${a}deg) `), o && (s += `skewY(${o}deg) `) } let o = t.x.scale * e.x, l = t.y.scale * e.y; return (1 !== o || 1 !== l) && (s += `scale(${o}, ${l})`), s || "none" }(this.projectionDeltaWithTransform, this.treeScale, n); i && (r = i(n, r)), t.transform = r; let { x: a, y: o } = this.projectionDelta; for (let e in t.transformOrigin = `${100 * a.origin}% ${100 * o.origin}% 0`, s.animationValues ? t.opacity = s === this ? n.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : n.opacityExit : t.opacity = s === this ? void 0 !== n.opacity ? n.opacity : "" : void 0 !== n.opacityExit ? n.opacityExit : 0, eB) { if (void 0 === n[e]) continue; let { correct: i, applyTo: a, isCSSVariable: o } = eB[e], l = "none" === r ? n[e] : i(n[e], s); if (a) { let e = a.length; for (let i = 0; i < e; i++)t[a[i]] = l } else o ? this.options.visualElement.renderState.vars[e] = l : t[e] = l } this.options.layoutId && (t.pointerEvents = s === this ? e7(e?.pointerEvents) || "" : "none") } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(t => t.currentAnimation?.stop()), this.root.nodes.forEach(nK), this.root.sharedNodes.clear() } } } function nz(t) { t.updateLayout() } function nY(t) { let e = t.resumeFrom?.snapshot || t.snapshot; if (t.isLead() && t.layout && e && t.hasListeners("didUpdate")) { let { layoutBox: i, measuredBox: s } = t.layout, { animationType: n } = t.options, r = e.source !== t.layout.source; "size" === n ? sG(t => { let s = r ? e.measuredBox[t] : e.layoutBox[t], n = sY(s); s.min = i[t].min, s.max = s.min + n }) : n7(n, e.layoutBox, i) && sG(s => { let n = r ? e.measuredBox[s] : e.layoutBox[s], a = sY(i[s]); n.max = n.min + a, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[s].max = t.relativeTarget[s].min + a) }); let a = ep(); sX(a, i, e.layoutBox); let o = ep(); r ? sX(o, t.applyTransform(s, !0), e.measuredBox) : sX(o, i, e.layoutBox); let l = !nD(a), h = !1; if (!t.resumeFrom) { let s = t.getClosestProjectingParent(); if (s && !s.resumeFrom) { let { snapshot: n, layout: r } = s; if (n && r) { let a = ef(); sq(a, e.layoutBox, n.layoutBox); let o = ef(); sq(o, i, r.layoutBox), nF(a, o) || (h = !0), s.options.layoutRoot && (t.relativeTarget = o, t.relativeTargetOrigin = a, t.relativeParent = s) } } } t.notifyListeners("didUpdate", { layout: i, snapshot: e, delta: o, layoutDelta: a, hasLayoutChanged: l, hasRelativeLayoutChanged: h }) } else if (t.isLead()) { let { onExitComplete: e } = t.options; e && e() } t.options.transition = void 0 } function nH(t) { t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty)) } function nX(t) { t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1 } function n_(t) { t.clearSnapshot() } function nK(t) { t.clearMeasurements() } function nq(t) { t.isLayoutDirty = !1 } function nG(t) { let { visualElement: e } = t.options; e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform() } function nZ(t) { t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0 } function nJ(t) { t.resolveTargetDelta() } function nQ(t) { t.calcProjection() } function n0(t) { t.resetSkewAndRotation() } function n1(t) { t.removeLeadSnapshot() } function n2(t, e, i) { t.translate = I(e.translate, 0, i), t.scale = I(e.scale, 1, i), t.origin = e.origin, t.originPoint = e.originPoint } function n5(t, e, i, s) { t.min = I(e.min, i.min, s), t.max = I(e.max, i.max, s) } function n3(t) { return t.animationValues && void 0 !== t.animationValues.opacityExit } let n6 = { duration: .45, ease: [.4, 0, .1, 1] }, n4 = t => "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), n8 = n4("applewebkit/") && !n4("chrome/") ? Math.round : tx; function n9(t) { t.min = n8(t.min), t.max = n8(t.max) } function n7(t, e, i) { return "position" === t || "preserve-aspect" === t && !(.2 >= Math.abs(nB(e) - nB(i))) } function rt(t) { return t !== t.root && t.scroll?.wasRoot } let re = nW({ attachResizeListener: (t, e) => sU(t, "resize", e), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), ri = { current: void 0 }, rs = nW({ measureScroll: t => ({ x: t.scrollLeft, y: t.scrollTop }), defaultParent: () => { if (!ri.current) { let t = new re({}); t.mount(window), t.setOptions({ layoutScroll: !0 }), ri.current = t } return ri.current }, resetTransform: (t, e) => { t.style.transform = void 0 !== e ? e : "none" }, checkIsScrollRoot: t => "fixed" === window.getComputedStyle(t).position }); function rn(t, e) { let i = function (t, e, i) { if (t instanceof EventTarget) return [t]; if ("string" == typeof t) { let e = document, i = (void 0) ?? e.querySelectorAll(t); return i ? Array.from(i) : [] } return Array.from(t) }(t), s = new AbortController; return [i, { passive: !0, ...e, signal: s.signal }, () => s.abort()] } function rr(t) { return !("touch" === t.pointerType || sI.x || sI.y) } function ra(t, e, i) { let { props: s } = t; t.animationState && s.whileHover && t.animationState.setActive("whileHover", "Start" === i); let n = s["onHover" + i]; n && tP.postRender(() => n(e, sW(e))) } function ro(t) { return nd(t) && "offsetHeight" in t } let rl = (t, e) => !!e && (t === e || rl(t, e.parentElement)), rh = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]), ru = new WeakSet; function rd(t) { return e => { "Enter" === e.key && t(e) } } function rc(t, e) { t.dispatchEvent(new PointerEvent("pointer" + e, { isPrimary: !0, bubbles: !0 })) } function rp(t) { return s$(t) && !(sI.x || sI.y) } function rm(t, e, i) { let { props: s } = t; if (t.current instanceof HTMLButtonElement && t.current.disabled) return; t.animationState && s.whileTap && t.animationState.setActive("whileTap", "Start" === i); let n = s["onTap" + ("End" === i ? "" : i)]; n && tP.postRender(() => n(e, sW(e))) } let rf = new WeakMap, rg = new WeakMap, ry = t => { let e = rf.get(t.target); e && e(t) }, rv = t => { t.forEach(ry) }, rx = { some: 0, all: 1 }, rw = function (t, e) { if ("undefined" == typeof Proxy) return ih; let i = new Map, s = (i, s) => ih(i, s, t, e); return new Proxy((t, e) => s(t, e), { get: (n, r) => "create" === r ? s : (i.has(r) || i.set(r, ih(r, void 0, t, e)), i.get(r)) }) }({ animation: { Feature: class extends sN { constructor(t) { super(t), t.animationState || (t.animationState = function (t) { let e = e => Promise.all(e.map(({ animation: e, options: i }) => (function (t, e, i = {}) { let s; if (t.notify("AnimationStart", e), Array.isArray(e)) s = Promise.all(e.map(e => sk(t, e, i))); else if ("string" == typeof e) s = sk(t, e, i); else { let n = "function" == typeof e ? iu(t, e, i.custom) : e; s = Promise.all(sC(t, n, i)) } return s.then(() => { t.notify("AnimationComplete", e) }) })(t, e, i))), i = sB(), s = !0, n = e => (i, s) => { let n = iu(t, s, "exit" === e ? t.presenceContext?.custom : void 0); if (n) { let { transition: t, transitionEnd: e, ...s } = n; i = { ...i, ...s, ...e } } return i }; function r(r) { let { props: a } = t, o = function t(e) { if (!e) return; if (!e.isControllingVariants) { let i = e.parent && t(e.parent) || {}; return void 0 !== e.props.initial && (i.initial = e.props.initial), i } let i = {}; for (let t = 0; t < sD; t++) { let s = eP[t], n = e.props[s]; (eb(n) || !1 === n) && (i[s] = n) } return i }(t.parent) || {}, l = [], h = new Set, u = {}, d = 1 / 0; for (let e = 0; e < sL; e++) { var c, p; let m = sR[e], f = i[m], g = void 0 !== a[m] ? a[m] : o[m], y = eb(g), v = m === r ? f.isActive : null; !1 === v && (d = e); let x = g === o[m] && g !== a[m] && y; if (x && s && t.manuallyAnimateOnMount && (x = !1), f.protectedKeys = { ...u }, !f.isActive && null === v || !g && !f.prevProp || ew(g) || "boolean" == typeof g) continue; let w = (c = f.prevProp, "string" == typeof (p = g) ? p !== c : !!Array.isArray(p) && !sj(p, c)), b = w || m === r && f.isActive && !x && y || e > d && y, T = !1, P = Array.isArray(g) ? g : [g], S = P.reduce(n(m), {}); !1 === v && (S = {}); let { prevResolvedValues: A = {} } = f, M = { ...A, ...S }, E = e => { b = !0, h.has(e) && (T = !0, h.delete(e)), f.needsAnimating[e] = !0; let i = t.getValue(e); i && (i.liveStyle = !1) }; for (let t in M) { let e = S[t], i = A[t]; if (!u.hasOwnProperty(t)) (ic(e) && ic(i) ? sj(e, i) : e === i) ? void 0 !== e && h.has(t) ? E(t) : f.protectedKeys[t] = !0 : null != e ? E(t) : h.add(t) } f.prevProp = g, f.prevResolvedValues = S, f.isActive && (u = { ...u, ...S }), s && t.blockInitialAnimation && (b = !1); let C = x && w, V = !C || T; b && V && l.push(...P.map(e => { let i = { type: m }; if ("string" == typeof e && s && !C && t.manuallyAnimateOnMount && t.parent) { let { parent: s } = t, n = iu(s, e); if (s.enteringChildren && n) { let { delayChildren: e } = n.transition || {}; i.delay = sV(s.enteringChildren, t, e) } } return { animation: e, options: i } })) } if (h.size) { let e = {}; if ("boolean" != typeof a.initial) { let i = iu(t, Array.isArray(a.initial) ? a.initial[0] : a.initial); i && i.transition && (e.transition = i.transition) } h.forEach(i => { let s = t.getBaseTarget(i), n = t.getValue(i); n && (n.liveStyle = !0), e[i] = s ?? null }), l.push({ animation: e }) } let m = !!l.length; return s && (!1 === a.initial || a.initial === a.animate) && !t.manuallyAnimateOnMount && (m = !1), s = !1, m ? e(l) : Promise.resolve() } return { animateChanges: r, setActive: function (e, s) { if (i[e].isActive === s) return Promise.resolve(); t.variantChildren?.forEach(t => t.animationState?.setActive(e, s)), i[e].isActive = s; let n = r(e); for (let t in i) i[t].protectedKeys = {}; return n }, setAnimateFunction: function (i) { e = i(t) }, getState: () => i, reset: () => { i = sB() } } }(t)) } updateAnimationControlsSubscription() { let { animate: t } = this.node.getProps(); ew(t) && (this.unmountControls = t.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { let { animate: t } = this.node.getProps(), { animate: e } = this.node.prevProps || {}; t !== e && this.updateAnimationControlsSubscription() } unmount() { this.node.animationState.reset(), this.unmountControls?.() } } }, exit: { Feature: class extends sN { constructor() { super(...arguments), this.id = sO++ } update() { if (!this.node.presenceContext) return; let { isPresent: t, onExitComplete: e } = this.node.presenceContext, { isPresent: i } = this.node.prevPresenceContext || {}; if (!this.node.animationState || t === i) return; let s = this.node.animationState.setActive("exit", !t); e && !t && s.then(() => { e(this.id) }) } mount() { let { register: t, onExitComplete: e } = this.node.presenceContext || {}; e && e(this.id), t && (this.unmount = t(this.id)) } unmount() { } } }, inView: { Feature: class extends sN { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { var t; let e; this.unmount(); let { viewport: i = {} } = this.node.getProps(), { root: s, margin: n, amount: r = "some", once: a } = i, o = { root: s ? s.current : void 0, rootMargin: n, threshold: "number" == typeof r ? r : rx[r] }, l = t => { let { isIntersecting: e } = t; if (this.isInView === e || (this.isInView = e, a && !e && this.hasEnteredView)) return; e && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", e); let { onViewportEnter: i, onViewportLeave: s } = this.node.getProps(), n = e ? i : s; n && n(t) }; return t = this.node.current, e = function ({ root: t, ...e }) { let i = t || document; rg.has(i) || rg.set(i, {}); let s = rg.get(i), n = JSON.stringify(e); return s[n] || (s[n] = new IntersectionObserver(rv, { root: t, ...e })), s[n] }(o), rf.set(t, l), e.observe(t), () => { rf.delete(t), e.unobserve(t) } } mount() { this.startObserver() } update() { if ("undefined" == typeof IntersectionObserver) return; let { props: t, prevProps: e } = this.node;["amount", "margin", "root"].some(function ({ viewport: t = {} }, { viewport: e = {} } = {}) { return i => t[i] !== e[i] }(t, e)) && this.startObserver() } unmount() { } } }, tap: { Feature: class extends sN { mount() { let { current: t } = this.node; t && (this.unmount = function (t, e, i = {}) { let [s, n, r] = rn(t, i), a = t => { let s = t.currentTarget; if (!rp(t)) return; ru.add(s); let r = e(s, t), a = (t, e) => { window.removeEventListener("pointerup", o), window.removeEventListener("pointercancel", l), ru.has(s) && ru.delete(s), rp(t) && "function" == typeof r && r(t, { success: e }) }, o = t => { a(t, s === window || s === document || i.useGlobalTarget || rl(s, t.target)) }, l = t => { a(t, !1) }; window.addEventListener("pointerup", o, n), window.addEventListener("pointercancel", l, n) }; return s.forEach(t => { ((i.useGlobalTarget ? window : t).addEventListener("pointerdown", a, n), ro(t)) && (t.addEventListener("focus", t => ((t, e) => { let i = t.currentTarget; if (!i) return; let s = rd(() => { if (ru.has(i)) return; rc(i, "down"); let t = rd(() => { rc(i, "up") }); i.addEventListener("keyup", t, e), i.addEventListener("blur", () => rc(i, "cancel"), e) }); i.addEventListener("keydown", s, e), i.addEventListener("blur", () => i.removeEventListener("keydown", s), e) })(t, n)), rh.has(t.tagName) || -1 !== t.tabIndex || t.hasAttribute("tabindex") || (t.tabIndex = 0)) }), r }(t, (t, e) => (rm(this.node, e, "Start"), (t, { success: e }) => rm(this.node, t, e ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget })) } unmount() { } } }, focus: { Feature: class extends sN { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let t = !1; try { t = this.node.current.matches(":focus-visible") } catch (e) { t = !0 } t && this.node.animationState && (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { this.isActive && this.node.animationState && (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = iy(sU(this.node.current, "focus", () => this.onFocus()), sU(this.node.current, "blur", () => this.onBlur())) } unmount() { } } }, hover: { Feature: class extends sN { mount() { let { current: t } = this.node; t && (this.unmount = function (t, e, i = {}) { let [s, n, r] = rn(t, i), a = t => { if (!rr(t)) return; let { target: i } = t, s = e(i, t); if ("function" != typeof s || !i) return; let r = t => { rr(t) && (s(t), i.removeEventListener("pointerleave", r)) }; i.addEventListener("pointerleave", r, n) }; return s.forEach(t => { t.addEventListener("pointerenter", a, n) }), r }(t, (t, e) => (ra(this.node, e, "Start"), t => ra(this.node, t, "End")))) } unmount() { } } }, pan: { Feature: class extends sN { constructor() { super(...arguments), this.removePointerDownListener = tx } onPointerDown(t) { this.session = new sQ(t, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: sZ(this.node) }) } createPanHandlers() { let { onPanSessionStart: t, onPanStart: e, onPan: i, onPanEnd: s } = this.node.getProps(); return { onSessionStart: ne(t), onStart: ne(e), onMove: i, onEnd: (t, e) => { delete this.session, s && tP.postRender(() => s(t, e)) } } } mount() { this.removePointerDownListener = sz(this.node.current, "pointerdown", t => this.onPointerDown(t)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } }, drag: { Feature: class extends sN { constructor(t) { super(t), this.removeGroupControls = tx, this.removeListeners = tx, this.controls = new s7(t) } mount() { let { dragControls: t } = this.node.getProps(); t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || tx } unmount() { this.removeGroupControls(), this.removeListeners() } }, ProjectionNode: rs, MeasureLayout: nh }, layout: { ProjectionNode: rs, MeasureLayout: nh } }, (t, e) => eq(t) ? new e_(e) : new eI(e, { allowProjection: t !== a.Fragment })); var rb = a; function rT(t, e) { if ("function" == typeof t) return t(e); null != t && (t.current = e) } class rP extends rb.Component { getSnapshotBeforeUpdate(t) { let e = this.props.childRef.current; if (e && t.isPresent && !this.props.isPresent) { let t = e.offsetParent, i = ro(t) && t.offsetWidth || 0, s = this.props.sizeRef.current; s.height = e.offsetHeight || 0, s.width = e.offsetWidth || 0, s.top = e.offsetTop, s.left = e.offsetLeft, s.right = i - s.width - s.left } return null } componentDidUpdate() { } render() { return this.props.children } } function rS({ children: t, isPresent: e, anchorX: i, root: s }) {
    let n = (0, rb.useId)(), o = (0, rb.useRef)(null), l = (0, rb.useRef)({ width: 0, height: 0, top: 0, left: 0, right: 0 }), { nonce: h } = (0, rb.useContext)(eJ), u = function (...t) { return a.useCallback(function (...t) { return e => { let i = !1, s = t.map(t => { let s = rT(t, e); return i || "function" != typeof s || (i = !0), s }); if (i) return () => { for (let e = 0; e < s.length; e++) { let i = s[e]; "function" == typeof i ? i() : rT(t[e], null) } } } }(...t), t) }(o, t?.ref); return (0, rb.useInsertionEffect)(() => {
      let { width: t, height: r, top: a, left: u, right: d } = l.current; if (e || !o.current || !t || !r) return; let c = "left" === i ? `left: ${u}` : `right: ${d}`; o.current.dataset.motionPopId = n; let p = document.createElement("style"); h && (p.nonce = h); let m = s ?? document.head; return m.appendChild(p), p.sheet && p.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${t}px !important;
            height: ${r}px !important;
            ${c}px !important;
            top: ${a}px !important;
          }
        `), () => { m.contains(p) && m.removeChild(p) }
    }, [e]), (0, r.jsx)(rP, { isPresent: e, childRef: o, sizeRef: l, children: rb.cloneElement(t, { ref: u }) })
  } let rA = ({ children: t, initial: e, isPresent: i, onExitComplete: s, custom: n, presenceAffectsLayout: o, mode: l, anchorX: h, root: u }) => { let d = e9(rM), c = (0, a.useId)(), p = !0, m = (0, a.useMemo)(() => (p = !1, { id: c, initial: e, isPresent: i, custom: n, onExitComplete: t => { for (let e of (d.set(t, !0), d.values())) if (!e) return; s && s() }, register: t => (d.set(t, !1), () => d.delete(t)) }), [i, d, s]); return o && p && (m = { ...m }), (0, a.useMemo)(() => { d.forEach((t, e) => d.set(e, !1)) }, [i]), a.useEffect(() => { i || d.size || !s || s() }, [i]), "popLayout" === l && (t = (0, r.jsx)(rS, { isPresent: i, anchorX: h, root: u, children: t })), (0, r.jsx)(e8.Provider, { value: m, children: t }) }; function rM() { return new Map } let rE = t => t.key || ""; function rC(t) { let e = []; return a.Children.forEach(t, t => { (0, a.isValidElement)(t) && e.push(t) }), e } let rV = ({ children: t, custom: e, initial: i = !0, onExitComplete: s, presenceAffectsLayout: n = !0, mode: o = "sync", propagate: l = !1, anchorX: h = "left", root: u }) => { let [d, c] = ns(l), p = (0, a.useMemo)(() => rC(t), [t]), m = l && !d ? [] : p.map(rE), f = (0, a.useRef)(!0), g = (0, a.useRef)(p), y = e9(() => new Map), [v, x] = (0, a.useState)(p), [w, b] = (0, a.useState)(p); il(() => { f.current = !1, g.current = p; for (let t = 0; t < w.length; t++) { let e = rE(w[t]); m.includes(e) ? y.delete(e) : !0 !== y.get(e) && y.set(e, !1) } }, [w, m.length, m.join("-")]); let T = []; if (p !== v) { let t = [...p]; for (let e = 0; e < w.length; e++) { let i = w[e], s = rE(i); m.includes(s) || (t.splice(e, 0, i), T.push(i)) } return "wait" === o && T.length && (t = T), b(rC(t)), x(p), null } let { forceRender: P } = (0, a.useContext)(eG); return (0, r.jsx)(r.Fragment, { children: w.map(t => { let a = rE(t), v = (!l || !!d) && (p === w || m.includes(a)); return (0, r.jsx)(rA, { isPresent: v, initial: (!f.current || !!i) && void 0, custom: e, presenceAffectsLayout: n, mode: o, root: u, onExitComplete: v ? void 0 : () => { if (!y.has(a)) return; y.set(a, !0); let t = !0; y.forEach(e => { e || (t = !1) }), t && (P?.(), b(g.current), l && c?.(), s && s()) }, anchorX: h, children: t }, a) }) }) }; function rk() { let [e, i] = (0, a.useState)(""), [s, n] = (0, a.useState)(null), [o, l] = (0, a.useState)(8), [h, u] = (0, a.useState)(!1), [d, v] = (0, a.useState)(null), [x, b] = (0, a.useState)(!1), T = async () => { if (e || s) { u(!0), v(null); try { let i = null; s && (i = await new Promise((t, e) => { let i = new FileReader; i.readAsDataURL(s), i.onload = () => t(i.result), i.onerror = t => e(t) })), console.log("Sending duration:", o); let n = ""; if (window.__adobe_cep__) { let { generateMusicCEP: s } = await t.A(17281); n = await s(e, i, o, (localStorage.getItem("sonic_forge_api_key") || "YOUR_REPLICATE_API_TOKEN")) } else { let t = await fetch("/api/generate", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ prompt: e, audio: i, duration: o }) }), s = await t.json(); if (s.error) throw Error(s.error); n = s.audio } n && v(`${n}?t=${Date.now()}`) } catch (t) { console.error("Error:", t), alert(`Something went wrong: ${t.message || t}`) } finally { u(!1) } } }, P = async () => { if (d) { if (!window.__adobe_cep__) return void alert("This feature is only available in After Effects."); try { let { evalScript: e, loadNodeModule: i } = await t.A(17281), s = i("fs"), n = i("https"), r = i("path"), a = i("os"); if (!s || !n || !r || !a) return void alert("Node.js modules not available."); let o = r.join(a.tmpdir(), `generated_music_${Date.now()}.mp3`), l = s.createWriteStream(o), h = d.split("?")[0]; n.get(h, function (t) { t.pipe(l), l.on("finish", async function () { l.close(async () => { let t = o.replace(/\\/g, "\\\\"), i = await e(`importFile("${t}")`); "Success" === i ? alert("Imported to timeline!") : alert("Import failed: " + i) }) }) }).on("error", t => { alert("Download failed: " + t.message) }) } catch (t) { alert("Import error: " + t.message) } } }, [S, A] = (0, a.useState)("text"); return (0, r.jsxs)("main", { className: "min-h-screen bg-[#121212] text-white font-sans overflow-hidden flex flex-col p-5 select-none", children: [(0, r.jsxs)("header", { className: "mb-8", children: [(0, r.jsxs)("div", { className: "flex items-center gap-2 mb-1", children: [(0, r.jsx)(p, { className: "w-6 h-6 text-[#3ea6ff]" }), (0, r.jsx)("h1", { className: "text-2xl font-bold tracking-tight text-[#f0f0f0]", children: "SonicForge" })] }), (0, r.jsx)("p", { className: "text-[10px] text-[#666] uppercase tracking-[0.2em] ml-8 font-medium", children: "AI Sound Effect Generator" })] }), (0, r.jsxs)("div", { className: "flex-1 space-y-6", children: [(0, r.jsxs)("div", { className: "flex gap-4", children: [(0, r.jsxs)("button", { onClick: () => A("text"), className: w("flex-1 py-3 rounded-full font-medium text-sm transition-all flex items-center justify-center gap-2 border-2", "text" === S ? "bg-[#2d5a88] border-[#2d5a88] text-white shadow-lg shadow-blue-900/20" : "bg-transparent border-[#333] text-[#666] hover:border-[#444] hover:text-[#888]"), children: [(0, r.jsx)(g, { className: "w-4 h-4" }), "Text to Sound"] }), (0, r.jsxs)("button", { onClick: () => A("remix"), className: w("flex-1 py-3 rounded-full font-medium text-sm transition-all flex items-center justify-center gap-2 border-2", "remix" === S ? "bg-[#2d5a88] border-[#2d5a88] text-white shadow-lg shadow-blue-900/20" : "bg-transparent border-[#333] text-[#666] hover:border-[#444] hover:text-[#888]"), children: [(0, r.jsx)(c, { className: "w-4 h-4" }), "Audio Remix"] })] }), (0, r.jsxs)("div", { className: "space-y-2", children: [(0, r.jsx)("label", { className: "text-xs text-[#666] uppercase tracking-wider font-semibold ml-1", children: "Prompt" }), "text" === S ? (0, r.jsx)("textarea", { value: e, onChange: t => i(t.target.value), placeholder: "Describe the sound or music...", className: "w-full h-28 bg-[#1e1e1e] rounded-3xl p-4 text-sm text-[#ffffff] placeholder:text-[#888] focus:outline-none focus:ring-2 focus:ring-[#2d5a88] transition-all resize-none border border-transparent focus:border-transparent" }) : (0, r.jsxs)("div", { className: "relative", onDragOver: t => { t.preventDefault(), t.stopPropagation() }, onDrop: t => { t.preventDefault(), t.stopPropagation(); let e = t.dataTransfer.files?.[0]; e && e.type.startsWith("audio/") && (n(e), "text" === S && A("remix")) }, children: [(0, r.jsx)("input", { type: "file", accept: "audio/*", onChange: t => { let e = t.target.files?.[0]; e && (n(e), "text" === S && A("remix")) }, className: "hidden", id: "audio-upload" }), (0, r.jsx)("label", { htmlFor: "audio-upload", className: w("flex flex-col items-center justify-center w-full h-28 rounded-3xl bg-[#1e1e1e] cursor-pointer transition-all border-2", s ? "border-[#2d5a88] bg-[#2d5a88]/10" : "border-transparent hover:bg-[#252525]"), children: s ? (0, r.jsxs)("div", { className: "flex flex-col items-center gap-2 text-[#3ea6ff]", children: [(0, r.jsx)(p, { className: "w-6 h-6" }), (0, r.jsx)("span", { className: "text-sm font-medium truncate max-w-[200px]", children: s.name }), (0, r.jsx)("span", { className: "text-[10px] opacity-60 uppercase tracking-wide", children: "Click to replace" })] }) : (0, r.jsxs)("div", { className: "flex flex-col items-center gap-2 text-[#666]", children: [(0, r.jsx)(c, { className: "w-6 h-6" }), (0, r.jsx)("span", { className: "text-sm font-medium", children: "Click or Drop Audio" })] }) })] })] }), (0, r.jsxs)("div", { className: "space-y-3 pt-2", children: [(0, r.jsxs)("div", { className: "flex justify-between text-xs items-center px-1", children: [(0, r.jsx)("span", { className: "text-[#666] font-medium", children: "Duration" }), (0, r.jsxs)("span", { className: "text-[#3ea6ff] font-bold", children: [o, "s"] })] }), (0, r.jsx)("input", { type: "range", min: "5", max: "30", value: o, onChange: t => l(parseInt(t.target.value)), className: "w-full h-2 bg-[#1e1e1e] rounded-full appearance-none cursor-pointer accent-[#3ea6ff]" })] }), (0, r.jsx)("button", { onClick: T, disabled: h || "text" === S && !e || "remix" === S && !s, className: "w-full py-4 rounded-full bg-[#2d5a88] hover:bg-[#356a9e] active:bg-[#254b73] text-white font-bold text-base transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2 shadow-xl shadow-black/20 mt-4", children: h ? (0, r.jsxs)(r.Fragment, { children: [(0, r.jsx)(y, { className: "w-5 h-5 animate-spin" }), "Generating..."] }) : "Generate Sound" }), (0, r.jsx)(rV, { children: d && (0, r.jsx)(rw.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, exit: { opacity: 0, y: 20 }, className: "mt-6", children: (0, r.jsxs)("div", { className: "bg-[#1e1e1e] rounded-xl p-4 flex items-center justify-between gap-4 border border-[#333]", children: [(0, r.jsxs)("div", { className: "flex items-center gap-3 min-w-0", children: [(0, r.jsx)("div", { className: "w-10 h-10 rounded-full bg-[#2d5a88]/20 flex items-center justify-center text-[#3ea6ff]", children: (0, r.jsx)(p, { className: "w-5 h-5" }) }), (0, r.jsxs)("div", { className: "min-w-0", children: [(0, r.jsx)("div", { className: "text-sm font-medium text-white", children: "Generated Audio" }), (0, r.jsxs)("div", { className: "text-xs text-[#666]", children: [o, "s  Ready"] })] })] }), (0, r.jsxs)("div", { className: "flex items-center gap-2", children: [(0, r.jsx)("audio", { src: d, id: "audio-player", className: "hidden", onPlay: () => b(!0), onPause: () => b(!1), onEnded: () => b(!1) }), (0, r.jsx)("button", { onClick: () => { let t = document.getElementById("audio-player"); t.paused ? t.play() : t.pause() }, className: "w-8 h-8 rounded-full bg-[#333] hover:bg-[#444] text-white flex items-center justify-center transition-colors", children: x ? (0, r.jsx)(f, { className: "w-4 h-4 fill-current" }) : (0, r.jsx)(m, { className: "w-4 h-4 fill-current ml-0.5" }) }), (0, r.jsx)("button", { onClick: P, className: "h-8 px-4 rounded-full bg-[#2d5a88] hover:bg-[#356a9e] text-white text-xs font-bold transition-colors shadow-lg", children: "Import" })] })] }) }) })] })] }) } t.s(["default", () => rk], 52683)
}]);